<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rexxxzhou.github.io</id>
    <title>Rexxxx&apos;s Blog</title>
    <updated>2023-03-12T11:59:38.996Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rexxxzhou.github.io"/>
    <link rel="self" href="https://rexxxzhou.github.io/atom.xml"/>
    <subtitle>Life is a fucking movie, enjoy.</subtitle>
    <logo>https://rexxxzhou.github.io/images/avatar.png</logo>
    <icon>https://rexxxzhou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Rexxxx&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[EffectiveGo笔记]]></title>
        <id>https://rexxxzhou.github.io/post/effectivego-bi-ji/</id>
        <link href="https://rexxxzhou.github.io/post/effectivego-bi-ji/">
        </link>
        <updated>2022-08-28T08:45:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="初始化">初始化</h3>
<h4 id="常量初始化">常量初始化</h4>
<p>**不管是全局常量还是在函数中声明的常量，常量是在编译器创建的，而且只能是数字类型、字符、字符串或布尔类型。**因为编译时的限制，定义常量的表达式必须是常量表达式，这样编译器在编译时才能计算常量的值，而不能是一些例如函数计算值，因为调用函数是在代码运行阶段才执行的。</p>
<h4 id="变量初始化">变量初始化</h4>
<p>变量的初始化可以是一般的表达式，因为这是在运行时才初始化的。</p>
<p>包的初始化<strong>首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化</strong>：</p>
<pre><code class="language-go">var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
</code></pre>
<p>所以在Go语言里，函数的声明顺序，变量的声明顺序都是无所谓的，没有强制要求先依赖的变量或者函数需要先进行声明和定义，Go语言在编译时会自动检查依赖关系，在依赖关系的基础上，然后再按照代码的声明顺序进行初始化。</p>
<h4 id="init函数">init函数</h4>
<p><strong>init函数的主要作用</strong>：1）初始化不能采用初始化表达式初始化的变量。2）程序运行前的注册。3）实现sync.Once功能。（备注：init函数没有输入参数、返回值。）</p>
<p>例如，可用于执行前对系统环境状态进行判断，决定是否继续执行程序：</p>
<pre><code class="language-go">var (
    home   = os.Getenv(&quot;HOME&quot;)
    user   = os.Getenv(&quot;USER&quot;)
    gopath = os.Getenv(&quot;GOPATH&quot;)
)

func init() {
    if user == &quot;&quot; {
        log.Fatal(&quot;$USER not set&quot;)
    }
    if home == &quot;&quot; {
        home = &quot;/home/&quot; + user
    }
    if gopath == &quot;&quot; {
        gopath = home + &quot;/go&quot;
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&amp;gopath, &quot;gopath&quot;, gopath, &quot;override default GOPATH&quot;)
}
</code></pre>
<p>init函数是在main函数执行前先执行的，总体的执行顺序为：</p>
<p>各变量的声明和初始化--》init函数--》main函数</p>
<p>一个包里可以有多个init函数，一个文件里也可以同时拥有多个init函数，在同一个文件中的多个init函数按照代码编写的顺序执行；而同一个包里多个文件都有init函数的情况下，则按照文件名字符串的比较后，从小到大执行，例如先执行a.go里的init，再执行b.go里的init函数。</p>
<p>导入的包会自动执行init函数，执行的顺序和包的依赖关系有关：</p>
<p>初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。<br>
<img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/170143478-1.png" alt="image" loading="lazy"></p>
<h3 id="接口和其他类型">接口和其他类型</h3>
<p>接口的类型断言如果失败，则返回的变量为该类型的零值：</p>
<pre><code class="language-go">val,ok:=myinter.(string)// 如果接口现在承载的不是string，则ok为false，val为字符串的空值，为空字符串
</code></pre>
<h4 id="定义函数类型别名">定义函数类型别名</h4>
<pre><code class="language-go">func main(){
	type HandlerFunc func(int)
	f := HandlerFunc(my_func)
	f(5)
}
func my_func(int) {
	fmt.Println(&quot;my_func&quot;)
}
//output
my_func
</code></pre>
<h4 id="下划线">下划线</h4>
<p>下划线的作用是因为Go语言如果变量或者导入的包没有用到，就无法通过编译，或者我们有时候确实不需要某个函数的返回值或某个对象，可以使用下划线_来忽略这个对象或者包，以通过编译。</p>
<p>因为如果没有用到的包我们又import了，若这种语法合法，那么编译器的工作量会很大，而且会多余的将这些包一起编译；没用到的变量同理，变量需要去计算它的值，但又后续用不到它，就是浪费资源。</p>
<p>使用下划线_就好比在linux系统下将东西写道/dev/null文件中，都是忽略不要的。</p>
<p>常见的用法：</p>
<pre><code class="language-go">_,ret:=my_func()
//忽略my_func函数的第一个返回值
</code></pre>
<p>也可以，但更多的是用上面的方式，下面累赘：</p>
<pre><code class="language-go">val,ret:=my_func()
_=val
</code></pre>
<p>如果导入某个包，但是又忽略不用，却要用到它的一些init函数，则可以：</p>
<pre><code class="language-go">import _ fmt 
//忽略fmt，在代码中无法使用fmt包
//This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn't have a name.
</code></pre>
<p>也可通过下面的方式对来消除编译器的报错提醒：</p>
<pre><code class="language-go">import(
	&quot;fmt&quot;
    &quot;time&quot;
)
var _ = fmt.Printf  //这里的Printf是个函数，相当于把这个函数的句柄赋给了_
var _ time.Duration //这里的Duration是个类型，这个语句就是普通的变量声明语句
//使用这种方法，就可以避免编译器报错，虽然这里用了_，但是Printf、Duration可以在代码中使用
</code></pre>
<p>在Go语言中，很多类型实现了接口，就可以通过接口变量来调用这些类型的实现的接口方法，在编译期间，编译器可以检查大多数的类型是否实现了接口，以判断是否通过编译，但也有些必须在运行时才能判断（例如下面的运行时类型判断）：</p>
<pre><code class="language-go">if _, ok := val.(json.Marshaler); ok {
    fmt.Printf(&quot;value %v of type %T implements json.Marshaler\n&quot;, val, val)
}

</code></pre>
<p>这种情况编译器是无能为力的，如果运行时才发现类型没有实现接口方法，但又调用了接口的方法，则会出错。</p>
<p>可以通过下划线_来实现一个检测，下面Marshaler是接口，右侧则是一个类型，下面这个语句可以实现在编译阶段判断(*RawMessage)类型有没有实现接口：</p>
<pre><code class="language-go">var _ json.Marshaler = (*RawMessage)(nil)

</code></pre>
<p>虽然通过这种方法可以在编译期间判断某个类型是否实现了接口，但没必要对每个类型都这么写，只要在用的地方做好类型断言就好了。</p>
<h4 id="嵌套">嵌套</h4>
<p>在Go语言中可以嵌套interface，也可以嵌套struct</p>
<p>若嵌套的struct A 实现了接口inter，则嵌套后，structB也实现了接口inter。但是如果在调用A实现的接口方法或者A自身的方法时，接收者都是A而不是B：</p>
<pre><code class="language-go">type A struct{
}
type B struct{
	A
}
func(a A) print(){
	fmt.Println(&quot;A's method&quot;)
}

</code></pre>
<p>如果嵌套的时候，还同时指定了这个嵌套类A的名字，此时则把这个看成一个成员：</p>
<pre><code>type B struct{
	a A
}

</code></pre>
<p>这时候就单纯理解为structB有个类型A的成员就行了，此时如果想要访问A的方法，只能通过普通的成员访问来实现，所以此时就不能说structB也实现了接口inter，<strong>要注意这里的成员和单纯嵌套（必须是匿名成员）的区别</strong>:</p>
<pre><code class="language-go">b:=B{}
b.a.AMethod()

</code></pre>
<p>因此，<strong>使用structA的指针类型嵌套也是可以的</strong>，也相当于实现了接口inter，：</p>
<pre><code class="language-go">type B struct{
	*A
}

</code></pre>
<p>对于嵌套时，内部类型同名与外层类型种同名的方法或者变量，如果直接访问，则访问的是外层的数据对象：</p>
<pre><code class="language-go">type A struct{
	hello string
}
type B struct{
	A
	hello string
}
func main(){
	b:=B{}
	fmt.Println(b.hello) //访问的是B中的hello，而不是A中的hello
}

</code></pre>
<p>struct中嵌套的类型名和别的类型后者成员不能重名，当然也有例外情况，例外情况现在没搞懂：</p>
<pre><code class="language-go">type st2 struct{
	*st1
	st1 string
}//这是不允许的，编译过不了

</code></pre>
<p>Second, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embed <code>log.Logger</code> if the <code>Job</code> struct contained another field or method called <code>Logger</code>. <strong>However</strong>, if the duplicate name is never mentioned in the program outside the type definition, it is OK. This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.</p>
<h4 id="作用域">作用域</h4>
<p><strong>内部作用域可以访问外部作用域中的对象，反之则不行；可以存在同名的对象，只要他们的作用域不同即可。</strong></p>
<p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</p>
<p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：</p>
<pre><code class="language-Go">func f() {}

var g = &quot;g&quot;

func main() {
    f := &quot;f&quot;
    fmt.Println(f) // &quot;f&quot;; local var f shadows package-level func f
    fmt.Println(g) // &quot;g&quot;; package-level var
    fmt.Println(h) // compile error: undefined: h
}

</code></pre>
<p>if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：</p>
<pre><code class="language-Go">if x := f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // compile error: x and y are not visible here

</code></pre>
<p><strong>第二个if语句嵌套在第一个内部</strong>（除了第一个if，其他if分支都是同级的作用域，嵌套在第一个if作用域下），因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后是每个分支的词法域。</p>
<h4 id="type-类型名-底层数据结构">type 类型名 底层数据结构</h4>
<p>这个需要注意的是，即使底层数据结构是相同的，不同的类型名，go当成不同的类型，所以即使底层数据结构相同，想在两种类型名之间进行运算，需要进行强制转换。</p>
<p>通过这种方式生成新的类型名，底层数据结构支持的运算符，新的类型名也是支持的。</p>
<h4 id="字符串需要注意的点">字符串需要注意的点</h4>
<p>更详细的教程见http://books.studygolang.com/gopl-zh/ch3/ch3-05.html</p>
<p>字符串是一个不可变对象，不像C++中的string可以append，go的字符串是不可变的，但是可以通过重新赋值改变对象的值：</p>
<pre><code class="language-go">s:=&quot;hello world&quot;
s[1]='L' //error 不可变对象，不可修改
s=&quot;new hello world&quot;  //correct 可以重新赋值

</code></pre>
<p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。<strong>在这两种情况下都没有必要分配新的内存。</strong> 这种情况就和切片相似，两个对象指向的是同一个底层数据，并没有开辟新的内存。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/170202737-1.png" alt="image" loading="lazy"></figure>
<p>对字符串使用len函数，返回的是底层数据的字节数，而不是字符数（例如一个中文字计算的是3）。</p>
<p>对一个字符串对象，可以像切片那样，获取部分子串，以形成一个新的字符串（左闭右开）：</p>
<pre><code class="language-go">s:=&quot;hello,world&quot;
s1:=s[:5]
s2:=s[5:]
s3:=s[0:5]

</code></pre>
<p>字符串的比较运算是按照逐字节比较的，所以必须是在同一字符集编码下才有意义。</p>
<p>字符串的转义符：</p>
<pre><code>\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号（只用在 '\'' 形式的rune符号面值中）
\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）
\\      反斜杠

</code></pre>
<p>可以通过十六进制和八进制转移值来指定字符串每个字节的值， 一个十六进制的转义形式是<code>\xhh</code>，其中两个h表示<strong>十六进制数字</strong>（大写或小写都可以）。一个八进制转义形式是<code>\ooo</code>，包含<strong>三个八进制的o数字</strong>（0到7），但是不能超过<code>\377</code>（译注：<strong>对应一个字节的范围，十进制为255</strong>）。 注意在十六进制和八进制转义中，都是数字，例如\x22，\035。</p>
<p><strong>原生字符串，使用反引号``括起来</strong>，此时，括起来的内容和字面值一样，可以理解成你写了什么，这个字符串就是什么内容，如果需要在原生字符串中出现反引号，可以通过+&quot;`&quot;连接字符串。 <strong>唯一的特殊处理是会删除回车</strong>以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统 。</p>
<pre><code class="language-go">s := `
hello 
world
nihao
\x23
`
fmt.Println(s + &quot;`&quot;)
//output

        hello 
        world
        nihao
        \x23
        `

</code></pre>
<p>**原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。**原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>
<h5 id="unicode编码">Unicode编码</h5>
<p>使用Unicode（ <a href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，<strong>Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。</strong></p>
<p>我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示。而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符。但是，还有其它更好的编码方法吗？ ==》<strong>UTF8</strong></p>
<h5 id="utf8">UTF8</h5>
<p>UTF8是一个<strong>将Unicode码点编码</strong>为字节序列的变长编码。</p>
<p><strong>UTF8编码使用1到4个字节来表示每个Unicode码点</strong>，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。<strong>每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节</strong>。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；<strong>后续的每个高端bit都以10开头</strong>。更大的Unicode码点也是采用类似的策略处理。 <strong>前四位高端位的1的个数代表某个字符编码的字节总数。</strong></p>
<pre><code>0xxxxxxx                             runes 0-127    (ASCII)
110xxxxx 10xxxxxx                    128-2047       (values &lt;128 unused)
1110xxxx 10xxxxxx 10xxxxxx           2048-65535     (values &lt;2048 unused)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  65536-0x10ffff (other values unused)

</code></pre>
<pre><code>&quot;世界&quot;
&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;
&quot;\u4e16\u754c&quot;
&quot;\U00004e16\U0000754c&quot;

</code></pre>
<p>上述的三种写法得到的结果都是“世界”，首先第一行其实就是utf8编码值对应的十六进制值，这个很好理解。</p>
<p>第二行则是utf8的转义值，这里详细解释下，以“世”为例，其对应的二进制值为：</p>
<p>11100100 10111000 10010110，根据编码方式（如上所示），去掉第一个字节的前四位，第二和第三字节的前两位，然后再拼到一起，得到：0100 1110 0001 0110 对应的就是\u4e16</p>
<p>再举一个unicode码点为4个字节的例子，码点值为65536时，对应有四个字节：</p>
<pre><code class="language-go">s := string(65536)
fmt.Printf(&quot;%x\n&quot;, s)
fmt.Println(len(s))
fmt.Println(&quot;\U00010000&quot; == s)
//output
f0908080
4
true

</code></pre>
<p>s对应的十六进制为f0908080，则相应的二进制为：</p>
<p>11110000 10010000 10000000 10000000</p>
<p>一样，去掉高位11110和后面字节的10后：</p>
<p>000 010000 000000 000000  因为位数不足8的整数倍（也即不是字节的倍数），所以前面在最前面补0：<br>
0000 0001 0000 0000 0000 0000  因此对应的utf的转义值就是\U00010000，所以上述代码中的相等比较是true</p>
<p>因为不同字符对应的编码字节数不一定相等，所以变长的编码无法直接通过索引来访问第n个字符。</p>
<p>没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。 <strong>（每个字符的编码都不相同，都不是各自的子串，匹配搜索的相率更高，无干扰。）</strong></p>
<p><strong>Go语言的源文件采用UTF8编码</strong>，并且Go语言处理UTF8编码的文本也很出色。</p>
<p>有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。<strong>Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。</strong>  <strong>有两种形式：</strong><code>\uhhhh</code>对应<strong>16bit</strong>的码点值，<code>\Uhhhhhhhh</code>对应<strong>32bit</strong>的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。</p>
<p>得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。 例如查找前缀，由于均由utf8编码，不用担心匹配的子串和原字符串存在编码上的区别，可以直接进行比对：</p>
<pre><code class="language-Go">func HasPrefix(s, prefix string) bool {
    return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix
}

</code></pre>
<p>Go语言的range循环，在遍历一个utf8字符串时，会进行隐式的解码，遍历的是每个unicode字符，并不是遍历每个字节，得到的是字符的Unicode码点值：</p>
<pre><code class="language-go">us := &quot;hello, 中国&quot;
for _, val := range us {
	fmt.Printf(&quot;%q\t%d\n&quot;, val, val)
}
//output
'h'     104
'e'     101
'l'     108
'l'     108
'o'     111
','     44
' '     32
'中'    20013
'国'    22269

</code></pre>
<p>**文本字符串采用UTF8编码只是一种惯例，**但是对于循环的真正字符串并不是一个惯例，这是正确的。如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编码的UTF8数据，将会发生什么呢？</p>
<p>每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，<strong>如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符<code>\uFFFD</code></strong>，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号&quot;?&quot;。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。</p>
<p>utf8编码的字符串是可以和rune数据或切片进行互相转换的：</p>
<p>一个[]byte(s)转换是<strong>分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。</strong></p>
<pre><code class="language-go">us := &quot;hello, 中国&quot;
rs := []rune(us)
nus:=string(rs)

</code></pre>
<p><strong>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串</strong>，由于utf8兼容ascii，所以使用ascii码对应的值来转换生成字符串是对的：</p>
<pre><code class="language-Go">fmt.Println(string(65))     // &quot;A&quot;, not &quot;65&quot;
fmt.Println(string(0x4eac)) // &quot;京&quot;

</code></pre>
<p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换：</p>
<pre><code class="language-Go">fmt.Println(string(1234567)) // &quot;?&quot;

</code></pre>
<h5 id="字符串和数字的转换">字符串和数字的转换</h5>
<p>1.使用fmt.Sprintf</p>
<pre><code class="language-go">x:=123
y:=fmt.Sprintf(&quot;%d&quot;,x)

</code></pre>
<p>2.使用strconv包的Itoa函数</p>
<pre><code class="language-go">x:=123
y:=strconv.Itoa(x)

</code></pre>
<p>3.将数字格式化为指定进制的字符串值</p>
<pre><code class="language-go">x:=123
y:=strconv.FormatInt(int64(x),2) //二进制 &quot;1111011&quot;

</code></pre>
<p>4.将字符串转为数字， 以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数 :</p>
<pre><code class="language-Go">x, err := strconv.Atoi(&quot;123&quot;)             // x is an int
y, err := strconv.ParseInt(&quot;123&quot;, 10, 64) // base 10, up to 64 bits

</code></pre>
<p>ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。</p>
<p><strong>标准库中有四个包对字符串处理尤为重要</strong>：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>
<p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p>
<p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言网络开发]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-wang-luo-kai-fa/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-wang-luo-kai-fa/">
        </link>
        <updated>2022-08-28T08:45:40.000Z</updated>
        <content type="html"><![CDATA[<p>**io.Writer接口的Write函数在实际写的字节数小于给定的byte切片长度时，会返回非空错误。**对于Write函数而言，可以直接根据返回的err信息来判断是否发送了完整数据。</p>
<p><strong>io.Reader接口</strong>的Read函数返回读到的字节数，如果已经快读到流的末端，返回的字节数大于0，则返回的错误可能是EOF也可能是nil，此时下次Read操作返回的是0，EOF；因此对于Read操作，需要先判断读取的字节数是否大于0来判断是否读取正常，然后再根据err来判断读取的状态信息。</p>
<p><strong>net.Conn是一个接口</strong>，Accept()函数返回的就是该接口对象，只是在返回前，该接口对象已经包含了具体的套接字信息，所以通过这个接口的方法可以直接操作该网络连接：</p>
<pre><code class="language-go">//假设类型A实现了接口myinter
var inter myinter=A{}
inter.Read() //就是执行了A实现的接口方法，因此Conn的处理同理
</code></pre>
<p>而<strong>带有具体协议名的Conn</strong>，例如TCPConn<strong>就是一个结构体类型</strong>，这些具体协议名的连接类型，<strong>都实现了net.Conn接口</strong>，所以可以直接传给参数为net.Conn类型的函数：</p>
<pre><code class="language-go">func main(){
	conn,err:=net.DialTCP(&quot;tcp&quot;,nil,tcpAddr) //conn is TCPCoon
	Sending(conn)
}


func Sending(net.Conn){
 /*code*/
}
</code></pre>
<p>Go语言的网络开发中，Dial函数用于连接对端服务器，服务器端使用Listen函数返回的监听者对象，调用监听者对象的Accept函数在服务端得到该连接的句柄。</p>
<p>整体上Dial，Listen，listener.Accept()，三个函数（方法）就能建立连接，前置的则是地址的处理。</p>
<p>对于没有协议名的Dial和Listen函数，地址是一形如“127.0.0.1:9528”的字符串，函数会自动解析地址信息</p>
<p>而有协议名的Dial和Listen函数，则需要传入相应协议的地址结构体，例如TCPAddr类型的对象，需要先通过ResolveTCPAddr函数获得TCPAddr类型的对象，传给解析函数的是形如“127.0.0.1:9528”的字符串。</p>
<p>只有对具体协议的连接对象（例如TCPConn）调用方法，才能设置该连接的设置，例如TCP的SetNoDelay。如果是形如TCPListener的监听者，可以调用AcceptTCP的方法来得到TCPConn对象，而Accept函数一律返回的是net.Conn的对象，所以通过前者得到TCPConn，服务端才能设置该连接的套接字设置。而客户端调用DialTCP返回的就是TCPConn类型。</p>
<pre><code class="language-go">listener,err:=net.ListenTCP(&quot;tcp&quot;,peerTCPAddr)
tcpconn,err:=listener.AcceptTCP()
tcpconn.SetNoDelay()
</code></pre>
<h3 id="go语言网络编程">Go语言网络编程</h3>
<p>官网的net包说明文档：</p>
<p>https://golang.org/pkg/net/#pkg-examples</p>
<p>net包支持TCP/IP，UDP，DNS域名解析，Unix域套接字编程，甚至有http编程。</p>
<p>虽然包支持了低层次的网络编程原语，但一般只需要基本的接口就可以实现网络编程，例如函数Dial，Listen，Accept和接口Conn，Listener等。</p>
<pre><code class="language-go">//client connect server
conn,err:=net.Dial(&quot;tcp&quot;,&quot;127.0.0.1:9527&quot;) //返回的conn就是套接字的句柄
</code></pre>
<pre><code class="language-go">//server deals with connection
listen_fd,err:=net.Listen(&quot;tcp&quot;,&quot;127.0.0.1:9527&quot;)
conn,conn_err:=listen_fd.Accept()//accept连接，服务端得到套接字句柄conn
</code></pre>
<p>在Unix系统下，DNS域名解析有两种方式，一种是使用Go自带的解析器，另一种是使用C语言库的解析器，两者最大的区别在于前者使用一个goroutine去解析，而后者要使用一个线程，效率上前者更优。默认情况下是使用前者。</p>
<p><code>net.Listen</code>这一系列函数，<strong>完成了C++中的socket，bind和listen三个函数的工作</strong>，返回的是一个监听者listener的句柄，通过这个listener来accept，在Go语言层面没有fd的说法。</p>
<p>net包中处理具体协议的api和通用网络通信api，例如Listen和ListenTCP之间的区别就是，带了协议名称的api，返回的是相应协议链接的类型，例如TCPConn，而没带的则返回的是Conn类型的对象。不带协议名的api可以实现带协议名api的功能，只需要补充一些参数即可。Conn类型可以用于网络通信，只是带协议名的具体Conn类型则可能支持协议的某些操作，例如TCPConn支持SetKeepAlive操作。</p>
<p><strong>By default the pure Go resolver is used,</strong> because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name.</p>
<p>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:</p>
<pre><code>export GODEBUG=netdns=go    # force pure Go resolver
export GODEBUG=netdns=cgo   # force cgo resolver
</code></pre>
<p>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag.</p>
<p><strong>A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions.</strong> To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1.</p>
<h5 id="函数netjoinhostport">函数net.JoinHostPort</h5>
<pre><code class="language-go">func JoinHostPort(host string,port string) string// 拼接ip地址和端口得到&quot;host:port&quot;
</code></pre>
<h5 id="函数netlookupaddress">函数net.LookUpAddress</h5>
<pre><code class="language-go">func LookUpAddress(addr string) ([]string,error)//反向查找地址对应的域名
//example
names, lk_err := net.LookupAddr(&quot;127.0.0.1&quot;)
fmt.Println(names)
//output
[VM-0-14-centos VM-0-14-centos localhost.localdomain. localhost localhost4.localdomain4. localhost4]
</code></pre>
<h5 id="函数netlookuphost">函数net.LookUpHost</h5>
<pre><code class="language-go">func LookupHost(host string) (addrs []string, err error)//查询主机名对应的ip地址
//example
addr, lk_err := net.LookupCNAME(&quot;localhost&quot;)
fmt.Println(addr)
//output
[::1 127.0.0.1]
</code></pre>
<h5 id="函数netparsecidr">函数net.ParseCIDR</h5>
<pre><code class="language-go">func ParseCIDR(s string) (IP, *IPNet, error)
//解析CIDR地址，得到相应的IP和网络
ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.
</code></pre>
<h5 id="函数netpipe">函数net.Pipe</h5>
<pre><code class="language-go">func Pipe() (Conn, Conn) //返回全双工的、同步的、在内存中的网络通信
//看到返回值是两个net.Conn类型；这类似于POSIX的pipe函数，只不过这里是通过Conn类型来进行通信的
//要注意的是这两个Conn是没有缓存的，有点类似Go中的channel类型。
</code></pre>
<h5 id="函数netsplithostport">函数net.SplitHostPort</h5>
<pre><code class="language-go">func SplitHostPort(hostport string) (host, port string, err error)
//将ip:port地址转换返回ip和port
</code></pre>
<p>Go中暴露给用户的网络接口函数是建立在POSIX网络接口的基础上的，但由于Go语言通过runtime来实现各goroutine的调度，所以这些网络接口与POSIX有一定的区别。</p>
<p><strong>Go的开发者无需关注sockfd是阻塞还是非阻塞的，也无需注册sockfd的回调函数，只需要在每个连接对应的goroutine中以阻塞I/O的方式处理套接字即可。</strong>（这是由于runtime和goroutine的GPM调度决定的）</p>
<p>一个简单的server端</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
)

func handler(conn net.Conn) { //传的是接口对象，而由于实现该接口的tcpConn是通过指针方式实现的，所以其实本质上是个引用传递
	defer conn.Close()
	buf := make([]byte, 20)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			fmt.Println(&quot;Read failed&quot;)
			fmt.Println(err.Error())
			break
		}
		fmt.Println(conn.RemoteAddr().String())
		fmt.Println(&quot;Recevied &quot;, n, &quot; bytes&quot;)
		recv_str := string(buf)
		fmt.Println(&quot;Received str: &quot;, recv_str)
		//time.Sleep(time.Second * 4)
	}
}

func main() {
	listen, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:9235&quot;)
	if err != nil {
		fmt.Println(&quot;Create listen sockfd failed&quot;)
		fmt.Println(err.Error())
		return
	}
	for {
		conn, listen_err := listen.Accept()
		if listen_err != nil {
			fmt.Println(&quot;accept failed&quot;)
			continue
		}
		go handler(conn)
	}
}

</code></pre>
<p>一个简单的client端</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:9235&quot;)
	if err != nil {
		fmt.Println(&quot;Connect failed&quot;)
		fmt.Println(err.Error())
		return
	}
	defer conn.Close()
	str := &quot;nihao&quot;
	n, write_err := conn.Write([]byte(str))
	if write_err != nil {
		fmt.Println(&quot;Write failed&quot;)
		fmt.Println(write_err.Error())
		return
	}
	fmt.Printf(&quot;Sent %d bytes&quot;, n)
	//time.Sleep(time.Second * 10)
}

</code></pre>
<p>用户层眼中看到的goroutine中的“block socket”，实际上是通过Go runtime中的netpoller通过Non-block socket + I/O多路复用机制“模拟”出来的，<strong>真实的底层socket实际上是non-block的</strong>，只是<strong>runtime拦截了底层socket系统调用的错误码，并通过netpoller和goroutine 调度让goroutine“阻塞”在用户层得到的Socket fd上</strong>。比如：当用户层针对某个socket fd发起read操作时，如果该socket fd中尚无数据，那么runtime会将该socket fd加入到netpoller中监听，同时对应的goroutine被挂起，直到runtime收到socket fd 数据ready的通知，runtime才会重新唤醒等待在该socket fd上准备read的那个Goroutine。而这个过程从Goroutine的视角来看，就像是read操作一直block在那个socket fd上似的。</p>
<p>若在客户端连接时发现对端不可达，或者对端没有监听指定端口，则net.Dial函数会立刻返回错误。</p>
<p>而<strong>在对端listen backlog（监听队列）未满之前</strong>，即使对端没有调用accept函数获取应用层使用的句柄（net.Conn对象），客户端的Dial连接服务端是成功返回的，出现这种情况的原因是TCP底层已经完成了连接，只是应用层代码还没有获取该套接字信息而已，客户端可以进行数据的发送。</p>
<p>直接使用net.Dial函数进行网络连接，可能会由于网络异常，或对端监听队列已满，导致无法连接，但该api是阻塞的，会一直等待网络连接的建立直到超时，而这个超时时间一般较长，以POSIX的api为例，connect的默认超时时间为75s。因此，可以使用net.DialTimeout这个函数指定连接的等待时间t，如果通过DNS解析出来的ip地址有多个，则等待时间t会被均分到每个ip的连接上。</p>
<h4 id="对端关闭连接">对端关闭连接</h4>
<p>若一端调用conn.Close()，关闭了连接，且该套接字接收缓冲去还有数据未读完，则另一端在读完剩余数据后，再进行读取，会得到EOF错误：</p>
<p>Read failed<br>
EOF</p>
<p>和POSIX一样，一旦对端关闭连接，则套接字状态是可读的，不会阻塞，可立刻进行读取。</p>
<h4 id="不要使用多个goroutine操作同一个conn">不要使用多个goroutine操作同一个conn</h4>
<p>这个和C++多线程网络开发是一样的，虽然可以用多线程去操作同一个套接字，但是由于TCP是字节流传输，线程调度顺序会影响读取的字节的顺序，所以不要这么做。</p>
<p>同理，虽然go语言里conn的read和write函数每次调用是加锁的，goroutine安全的，但是一样由于GPM调度顺序会影响得到的字节流的顺序，所以保证一个goroutine处理一个conn连接。</p>
<h4 id="socket属性">socket属性</h4>
<p>go语言基于原生的socket设置，也提供了一系列设置套接字属性的api，例如：</p>
<p>SetKeepAlive<br>
SetKeepAlivePeriod<br>
SetLinger<br>
SetNoDelay （默认no delay）<br>
SetWriteBuffer<br>
SetReadBuffer</p>
<p>上述这些设置是针对TCP的，所以在对conn进行设置前，需要进行类型断言：</p>
<pre><code class="language-go">tcpConn, ok := conn.(*TCPConn)
if !ok {
    //error handle
}

tcpConn.SetNoDelay(true)

</code></pre>
<h4 id="go为监听套接字默认设置了reuseaddr">Go为监听套接字默认设置了reuseaddr</h4>
<p>golang默认采用了 SO_REUSEADDR，这样当你重启 listener程序时，不会因为address in use的错误而启动失败。而listen backlog的默认值是通过获取系统的设置值得到的。不同系统不同：mac 128, linux 512等</p>
<h4 id="关闭连接">关闭连接</h4>
<p>当A端关闭连接后，该conn上的所有read和write操作都会失败返回：</p>
<pre><code>Write failed
write tcp 127.0.0.1:43222-&gt;127.0.0.1:9235: use of closed network connection
Read failed
read tcp 127.0.0.1:43222-&gt;127.0.0.1:9235: use of closed network connection

</code></pre>
<p>而B端读取会读到EOF，读取返回的字节数为0；但却可以继续向该连接进行write，这是因为发送的内容会写入到B端这边该conn的发送缓冲区，即使对面收不到。因此，一旦发现对端关闭了连接，则应立刻做好善后工作，B端也要进行连接的关闭。</p>
<h4 id="发送的数据长度">发送的数据长度</h4>
<p>发送的数据长度由切片[]byte的<strong>长度len</strong>决定，如果不通过类似buf[:5]这种方式进行指定发送那部分数据，而是将buf直接传给write函数，则发送的数据长度大小为该切片的长度大小（len函数的返回值），在Go中conn的Write接口是不需要指定发送多少个字节的，是自动判断的。</p>
<pre><code class="language-go">str := &quot;nihao&quot;
buf := make([]byte, 20)
buf = append(buf, []byte(str)[0])
_, write_err := conn.Write(buf)
//实际上发送了20个字节
//由于第二个字节开始就是空白符，服务端打印字符串的话只能打印出'n'

</code></pre>
<h4 id="读取的数据长度">读取的数据长度</h4>
<p>在使用conn.Read函数时，传入的切片对象的长度就是指定要读取的字节大小：</p>
<pre><code class="language-go">buf:=make([]byte,10)
conn.Read(buf[:3]) //指定读取3个字节
conn.Read(buf)//指定读取10个字节（切片的长度）

buf:=[20]byte{}
conn.Read(buf[:3])//指定读取3个字节
conn.Read(buf[:])//指定读取20个字节（切片的长度）

</code></pre>
<p><strong>所以不管读取还是发送，都要注意传给函数的切片参数要设置相应的长度，否则按照切片的容量大小去读取和发送了。</strong></p>
<hr>
<h4 id="nethttp">net.http</h4>
<p>注册handler的方式：</p>
<p>http.HandlerFunc(&quot;/&quot;,SomeFunc)</p>
<p>func SomeFunc(w http.ResponseWriter, r *http.Request) //SomeFunc的函数原型</p>
<p>这条路径匹配的含义是，所有host/的路径都匹配SomeFunc</p>
<p>如果同时有注册</p>
<p>http.HandlerFunc(&quot;/counter&quot;,AnotherFunc)</p>
<p>则host/pathname，除了pathname=counter以外，其他的均由SomeFunc处理，而pathname=counter则由AnotherFunc处理。</p>
<p>而如果注册的路径是http.HandlerFunc(&quot;/counter/&quot;,AnotherFunc)</p>
<p>则host/counter/pathname均由AnotherFunc处理。</p>
<hr>
<h4 id="json">JSON</h4>
<p>go语言自带的encoding/json包，可以实现json格式的序列化和反序列化，可以序列化的类型有对象(ex.结构体)、数组和基础类型，基础类型包括字符串、数值类型、布尔型和空（NULL）型。</p>
<p>对象，以序列化结构体为例，json格式下，是一个花括号括起来的整体。</p>
<p>对于不同类型的对象，json序列化的处理方式不同，如下所示：</p>
<p>1.Boolean values encode as JSON booleans.</p>
<p>2.Floating point and integer values encode as JSON numbers.</p>
<p>3.String values encode as JSON strings, with each invalid UTF-8 sequence replaced by the encoding of the<br>
Unicode replacement character U+FFFD.</p>
<p>4.Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string.</p>
<p>5.Struct values encode as JSON objects. Each struct field becomes a member of the object. By default the<br>
object's key name is the struct field name converted to lower case. If the struct field has a tag, that tag will<br>
be used as the name instead.</p>
<p>Json序列化结构体，默认将结构体的字段作为key_value对的key，并取小写，除非在struct定义中指定某个字段使用哪个key（这是成员的Tag， 通常是一系列用空格分隔的key:&quot;value&quot;键值对序列 ，对于用于指定json字段名的，key就是json，Tag一般为字符串面值，通过``来给出，因为value是&quot;&quot;括起来的）：</p>
<pre><code class="language-go">type Person  struct{
   　　Name  string   `json:&quot;name&quot;`　  //标记json名字为name　　　
   　　Age    int     `json:&quot;age&quot;`
   　　Time int64    `json:&quot;-&quot;`        // 标记忽略该字段

}

</code></pre>
<p>**只有字段首字母大写了，该字段信息才能序列化，否则序列化结果是没有这个字段的信息的。**如果字段名首字母不是大写，即使后面使用tag指定了json的字段名，也不会序列化。</p>
<p>6.Map values encode as JSON objects. The map's key type must be string; the object keys are used directly<br>
as map keys.</p>
<p>7.Pointer values encode as the value pointed to. (Note: this allows trees, but not graphs!). A nil pointer<br>
encodes as the null JSON object.</p>
<p>8.Interface values encode as the value contained in the interface. A nil interface value encodes as the null<br>
JSON object.</p>
<p>9.Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value<br>
cause Marshal to return an InvalidTypeError .</p>
<p>10.JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</p>
<h5 id="序列化">序列化</h5>
<p>json.NewEncoder(w io.Writer) 返回一个jsonEncoder对象的指针，然后通过这个对象进行编码：</p>
<pre><code class="language-go">encoder:=json.NewEncoder(conn)
encoder.Encode(content) // 将content对象的数据进行序列化

</code></pre>
<p>所有实现了io.Writer接口的对象都可以用于生成一个jsonEncoder，json编码的过程包含两部分，一是将内容序列化，而是调用对象的Write函数，进行写入。</p>
<p>所以如果传给NewEncoder，用于生成jsonEncoder的实参是一个网络conn类型，那么编码就相当于对该套接字发送序列化后的数据到对端。</p>
<h5 id="反序列化">反序列化</h5>
<p>json.NewDecoder(r io.Reader)返回一个jsonDecoder对象的指针，然后通过这个指针来进行解码：</p>
<pre><code class="language-go">decoder:=json.NewDecoder(conn)
decoder.Decode(&amp;obj)  //将反序列化后的内容写入到obj中，注意有取址符

</code></pre>
<p>所有实现了io.Reader接口的类型都可以用于生成jsonDecoder，反序列化也包含两部分，一是将序列化后的数据解码得到某个类型对象的数据，二是将该数据赋值给传入Decode方法的参数。反序列化调用了对象的Read函数，所以上述代码中，decoder反序列化时调用了conn的Read函数，从网络上读取了数据，再进行解码。</p>
<p>所以如果传给NewDecoder，用于生成jsonDecoder的实参是一个网络conn类型，那么解码就相当于对该套接字接受网络数据后再反序列化后写入到本地对象中。</p>
<p>根据源码分析，<strong>Encode和Decode方法都是处理了一个完整的json包之后才返回</strong>，所以调用这两个函数，goroutine会一直循环直到处理完完整的json包，因此发送和接受的网络数据都是一个完整的数据包，并且api已经帮我们做好了一切缓存的问题。</p>
<p>但需要注意的是，以Decode为例，假设一个包体总大小为20字节，存在Decode过程中向网络conn读取了超过20字节的情况（最小的读取长度为512字节），所以此时不要自己单独使用Read，会与json的Decode冲突，<strong>可能部分数据在Decoder的缓存中，保持只用一种方式来读取数据。</strong></p>
<p>Go语言特有的序列化和反序列化的package：gob，好处是在go语言编写的程序之间的通信较为高效，而且可以适应结构体的变化，例如：</p>
<p>This inclusion of type information makes Gob marshalling and unmarshalling fairly robust to changes or<br>
differences between the marshaller and unmarshaller. For example, a struct</p>
<p><strong>NewEncoder、NewDecoder是基于流式的编码解码器。</strong></p>
<h5 id="jsonmarshalv-interface-byteerror">json.Marshal(v interface{}) ([]byte,error)</h5>
<p>将传入的参数编码，返回编码后的字节切片。 Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进:</p>
<pre><code>[{&quot;Title&quot;:&quot;Casablanca&quot;,&quot;released&quot;:1942,&quot;Actors&quot;:[&quot;Humphrey Bogart&quot;,&quot;Ingr
id Bergman&quot;]},{&quot;Title&quot;:&quot;Cool Hand Luke&quot;,&quot;released&quot;:1967,&quot;color&quot;:true,&quot;Ac
tors&quot;:[&quot;Paul Newman&quot;]},{&quot;Title&quot;:&quot;Bullitt&quot;,&quot;released&quot;:1968,&quot;color&quot;:true,&quot;
Actors&quot;:[&quot;Steve McQueen&quot;,&quot;Jacqueline Bisset&quot;]}]

</code></pre>
<h5 id="jsonmarshalindentv-interfaceprefix-indentation-string-byteerror">json.MarshalIndent(v interface{},prefix, indentation string ) ([]byte,error)</h5>
<p>函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>
<pre><code class="language-Json">[
    {
        &quot;Title&quot;: &quot;Casablanca&quot;,
        &quot;released&quot;: 1942,
        &quot;Actors&quot;: [
            &quot;Humphrey Bogart&quot;,
            &quot;Ingrid Bergman&quot;
        ]
    },
    {
        &quot;Title&quot;: &quot;Cool Hand Luke&quot;,
        &quot;released&quot;: 1967,
        &quot;color&quot;: true,
        &quot;Actors&quot;: [
            &quot;Paul Newman&quot;
        ]
    },
    {
        &quot;Title&quot;: &quot;Bullitt&quot;,
        &quot;released&quot;: 1968,
        &quot;color&quot;: true,
        &quot;Actors&quot;: [
            &quot;Steve McQueen&quot;,
            &quot;Jacqueline Bisset&quot;
        ]
    }
]

</code></pre>
<h5 id="jsonunmarshaldata-bytev-interface-error">json.Unmarshal(data []byte,v interface{}) error</h5>
<p>将经过marshal序列化的字节切片反序列化，并将结果写入到v中。</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

type Name struct {
	FirstName string
	LastName  string
}

type FName struct {
	FirstName string
}

func main() {
	names := []Name{Name{FirstName: &quot;Rex&quot;, LastName: &quot;Zhou&quot;}, Name{FirstName: &quot;Chloe&quot;, LastName: &quot;Wang&quot;}}
	encoded, err := json.Marshal(names)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Println(encoded)

	var FNames []FName
	json.Unmarshal(encoded, &amp;FNames)
	for _, val := range FNames {
		fmt.Println(val)
	}
}

</code></pre>
<p>output：</p>
<pre><code>[91 123 34 70 105 114 115 116 78 97 109 101 34 58 34 82 101 120 34 44 34 76 97 115 116 78 97 109 101 34 58 34 90 104 111 117 34 125 44 123 34 70 105 114 115 116 78 97 109 101 34 58 34 67 104 108 111 101 34 44 34 76 97 115 116 78 97 109 101 34 58 34 87 97 110 103 34 125 93]
{Rex}
{Chloe}

</code></pre>
<p>可以看到，传给Unmarshal的对象，通过指定其结构体的字段，可以选择性的解码，上面只解码了FirstName，LastName没有解码。</p>
<h5 id="关于结构体中有指针类型的json编码和解码">关于结构体中有指针类型的json编码和解码</h5>
<p>一开始认为，如果结构体有指针，不管是自定义类型还是基础类型的指针，就是一个地址值而已，以为server传给client的就只有这个地址，而对于client而言，server的传来的地址值跟client是无关的，是server中局部变量的地址而已，所以对该现象表示疑问，因为有例子确实这样传输过来，client可以解引用该地址，得到正确的值。</p>
<p>经过测试发现，假设在server中变量A的地址为a，而实际client收到的地址值并不是a，而是别的值，假设为b；这是因为不只是简单的传了个十六进制的地址值过来，而是连同server中指针指向的对象值也传过来了：</p>
<p>server：</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;os&quot;
)

type Res struct {
	A *int
	B *int
}

func main() {
	listener, _ := net.Listen(&quot;tcp4&quot;, os.Args[1])
	for {
		conn, err := listener.Accept()
		if err != nil {
			continue
		}
		a, b := 123, 456
		sendData := Res{&amp;a, &amp;b}
		fmt.Println(&amp;a, &amp;b)
		encoder := json.NewEncoder(conn)
		encoder.Encode(sendData)
		conn.Close()
	}
}

</code></pre>
<p>client：</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;os&quot;
)

type Res struct {
	A *int
	B *int
}

func main() {
	conn, err := net.Dial(&quot;tcp4&quot;, os.Args[1])
	if err != nil {
		fmt.Println(err.Error())
	}
	decoder := json.NewDecoder(conn)
	var result Res
	decoder.Decode(&amp;result)
	fmt.Println(result.A, *result.A)
	fmt.Println(result.B, *result.B)
	conn.Close()
}

</code></pre>
<p>同一台机器下测试</p>
<p>在server中打印的局部变量的地址值为：</p>
<p>0xc0000182d0 0xc0000182d8</p>
<p>而在client中打印收到的地址值为：</p>
<p>0xc000018350 0xc000018360</p>
<p>可以看到两者是不同的，且client可以正常的进行解引用，知道传来的值分别为123和456.</p>
<p>所以使用json来传结构体中有指针的情况，不论指针有多少层（例如结构体A中有结构体B的指针，结构体B中有结构体C中的指针），不需要担心，它连同指向的底层数据也传过去了，并能够正确解码，在接收端能获取到具体数据。</p>
<p>虽然没有看具体api的源码，但猜测是发送端同时将指针和其指向的数据一同序列化发给对端，而对端在接收时，应该是先创建相应的数据对象，根据传来的数据对这些对象赋值，然后再对这些对象取址赋给对端的指针。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言数组与切片]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-shu-zu-yu-qie-pian/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-shu-zu-yu-qie-pian/">
        </link>
        <updated>2022-08-28T08:45:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go语言的数组">Go语言的数组</h3>
<p>声明数组的方法：</p>
<pre><code class="language-go">var variable_name [SIZE] variable_type
//e.x var myarray [5] int
//数组初始化
var array1 = [5] int{1,2,3} //指定数组长度并顺序初始化，没有初始化的为零值
array2:=[]int{1,2,3} //让编译器判断数组的长度(这是一个切片)

var array3=[...]int{1,2,3} //让编译器判断数组的长度(这是一个数组)
// array4:=[...]int{1:6,9:10} 根据给定的索引最大值确定数组的长度，因此该数组的长度为10
array4:=[5]int{1:2,3:5,4:10}//可以指定初始化某个位置的数组元素
array5:=array4 //可以直接通过旧数组来声明或赋值给新数组，新数组是旧数组的拷贝
</code></pre>
<h4 id="多维数组">多维数组</h4>
<p>声明方法：</p>
<pre><code class="language-go">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
//example
//var multi_array [2][3] int
</code></pre>
<pre><code class="language-go">multi_array := [][]int{}
row1 := []int{1, 2, 3}
row2 := []int{4, 5, 6}
multi_array = append(multi_array, row1)//append给数组填充内容，效果跟C++容器的insert相似，但需要接收返回值，否则没有实现添加
multi_array = append(multi_array, row2)
fmt.Println(multi_array[0])
fmt.Println(multi_array[1])
//输出[1 2 3] [4 5 6]
</code></pre>
<pre><code class="language-go">//创建各维度元素数量不一样的数组
package main

import &quot;fmt&quot;

func main() {
    // 创建空的二维数组
    animals := [][]string{}

    // 创建三一维数组，各数组长度不同
    row1 := []string{&quot;fish&quot;, &quot;shark&quot;, &quot;eel&quot;}
    row2 := []string{&quot;bird&quot;}
    row3 := []string{&quot;lizard&quot;, &quot;salamander&quot;}

    // 使用 append() 函数将一维数组添加到二维数组中
    animals = append(animals, row1)
    animals = append(animals, row2)
    animals = append(animals, row3)

    // 循环输出
    for i := range animals {
        fmt.Printf(&quot;Row: %v\n&quot;, i)
        fmt.Println(animals[i])
    }
}
</code></pre>
<p>初始化二维数组</p>
<pre><code class="language-go">a:=[2][3]int{
{1,2,3},
{4,5,6}} //最后一行的右侧括号不能单独成行，所以要这样写
或者
a:=[2][3]int{
{1,2,3},
{4,5,6},
} //这样就可以单独成行
</code></pre>
<h4 id="向函数传递数组参数">向函数传递数组参数</h4>
<pre><code class="language-go">func myfunc1 (array [] type) [return type]{ /* code */} //1
func myfunc2 (array [size] type) [return type]{ /* code */} //2
</code></pre>
<p>情况1：要注意指定了大小的数组（<strong>普通意义上的数组</strong>）只能传给指定了大小的形参的函数(上述的函数1)</p>
<p>情况2：没有指定长度的数组（在go中其实是<strong>切片</strong>类型）才能传给上述的函数2</p>
<p>声明数组：</p>
<pre><code>nums := [3]int{1,2,3,}
</code></pre>
<p>声明切片：</p>
<pre><code class="language-go">nums := []int{1,2,3}
</code></pre>
<p>没有声明长度的其实是切片，可以理解为数组，但本质上类型不一样，例如下方的函数传参处理方式就不一样。</p>
<p>- Go 语言的数组是值，其长度是其类型的一部分，作为函数参数时，是 <strong>值传递</strong>，函数中的修改对调用者不可见</p>
<p>- Go 语言中对数组的处理，一般采用 <strong>切片</strong> 的方式，切片包含对底层数组内容的引用，切片作为函数参数时，类似于 <strong>指针传递</strong>，函数中的修改对调用者可见</p>
<p>对于情况1，<strong>传给函数的数组是值传递</strong>，和C++不同，C++传的是本质上是个指针，所以在go语言中，函数内处理的是数组的副本，不影响原数组</p>
<pre><code class="language-go">func change(array []int) {
	array[0] = 100
}
func change_(array [5]int) {
	array[0] = 1000
}

array1 := [5]int{1, 2, 3}
fmt.Println(array1[0])
change_(array1)
fmt.Println(array1) 
//输出1 1

</code></pre>
<p>对于情况2，<strong>传给函数的数组是引用传递</strong></p>
<pre><code class="language-go">func change(array []int) {
	array[0] = 100
}
func change_(array [5]int) {
	array[0] = 1000
}

array1 := []int{1, 2, 3}
fmt.Println(array1[0])
change(array1)
fmt.Println(array1) 
//输出1 100

</code></pre>
<hr>
<h3 id="go语言的切片类型">Go语言的切片类型</h3>
<p><strong>切片的下标访问方式，索引不能超过其长度len</strong></p>
<pre><code class="language-go">arr2 := make([]int, 2, 10) //长度2 容量10的切片
fmt.Println(arr2[1]) //correct
fmt.Println(arr2[5]) //incorrect

</code></pre>
<p>一个奇怪但有趣的例子：</p>
<pre><code class="language-go">func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s)

	// 截取切片使其长度为 0
	s = s[:0]
	printSlice(s)

	// 拓展其长度
	s = s[:4]
	printSlice(s)

	// 舍弃前两个值
	s = s[2:]
	printSlice(s)
}

func printSlice(s []int) {
	fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)
}
//output
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]

</code></pre>
<p>直接下标访问例如arr[i]这样，i小于等于len(arr)-1。而如果通过上下界的方式来，就允许出现上面代码中扩展长度的用法（即使该语句中右侧的arr是个len=0的切片），要多加注意区分。<strong>个人觉得代码上尽量别这么写，自己都搞不明白，以后看代码更头疼。</strong>：</p>
<pre><code class="language-go">arr2 := make([]int, 0, 5)
fmt.Println(&quot;len of arr2&quot;, len(arr2), &quot;cap of arr2&quot;, cap(arr2))
arr2 = arr2[:5]
fmt.Println(arr2)
//output
len of arr2 0 cap of arr2 5
[0 0 0 0 0]

</code></pre>
<p><strong>切片的切片</strong>其实就是个二维切片，即切片的每个元素都是一个切片，和二维数组一样，每个元素都是一个切片。</p>
<pre><code class="language-go">arr5 := make([]([]int), 10)
arr5:=[][]int
//都是一个效果

</code></pre>
<p><strong>二维切片中的每一个切片的长度和容量都可以不一样。</strong></p>
<pre><code class="language-go">TwoDimArr := make([][]int, 5)
for i := 0; i &lt; 5; i++ {
TwoDimArr[i] = make([]int, 5, i+5)
}

</code></pre>
<p>每个元素可以直接通过下标赋值替换：</p>
<pre><code class="language-go">func main() {
	slice := Pic(5, 6)
	fmt.Println(slice)
	slice[0] = []uint8{1, 2, 3, 4, 5}
	fmt.Println(slice)
}
//output
[[0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4]]
[[1 2 3 4 5] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4] [0 1 2 3 4]]

</code></pre>
<p>切片其实和C++的vector很相似，是可以动态变化大小的，只不过在go语言里，语法上和go的数组操作很像。数组和切片的区别在于，<strong>数组的长度是固定，声明后不变，而切片的长度是可变的</strong>。</p>
<p>切片的长度是用户能够访问的索引上限，容量是切片当前可拥有的最大长度。</p>
<p>声明切片的方式：</p>
<pre><code class="language-go">var slice []type
slice:=[]type{1,2,3}
slice:=make([]type,len)
slice:=make([]type,len,cap) //len是切片的初始长度，cap是切片的容量，也即不用扩容前能容纳的最大元素数量

</code></pre>
<p><strong>切片的初始化</strong>（和python的列表下标使用方法很像）</p>
<p>通过对数组使用下标运算符来初始化，得到的是切片不是数组类型，而不加[]的话，则得到的是数组类型</p>
<pre><code class="language-go">array1:=[5]int{1,2,3,4,5}
array2:=array1//array2是数组类型
array3:=array1[:]//array3是切片类型

</code></pre>
<p>切片可以通过数组来初始化，也可以通过内置函数 make() 初始化。</p>
<p>初始化时 len=cap，在追加元素时如果容量 cap 不足时将按 len 的 <strong>2 倍</strong>扩容。</p>
<p><strong>s :=[] int {1,2,3 }</strong> 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3。其 cap=len=3。</p>
<p><strong>s := arr[:]</strong> 初始化切片 s，是<strong>数组 arr 的引用</strong>。</p>
<p><strong>s := arr[startIndex:endIndex]</strong> 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。</p>
<p><strong>s := arr[startIndex:]</strong> 缺省 endIndex 时将表示一直到 arr 的最后一个元素。</p>
<p><strong>s := arr[:endIndex]</strong> 缺省 startIndex 时将表示从 arr 的第一个元素开始。</p>
<p><strong>s1 := s[startIndex:endIndex]</strong> 通过切片 s 初始化切片 s1</p>
<p><strong>s :=make([]int,len,cap)</strong> 通过内置函数 make() 初始化切片 s,[]int 标识为其元素类型为 int 的切片。</p>
<p><strong>len函数是获取切片当前的元素个数，而cap函数获取的是切片的容量</strong></p>
<p>一个未经初始化的切片 var slice [] type是一个<strong>空切片</strong>，<strong>默认为nil</strong>，slice==nil</p>
<h4 id="切片截取">切片截取：</h4>
<p>可以<strong>通过设置下限及上限</strong>来设置截取切片 <em>[lower-bound:upper-bound]</em></p>
<p>依旧是<strong>左闭右开</strong>，跟上面切片初始化的用法相似arr[idx1:idx2]</p>
<h4 id="append和copy函数">append和copy函数</h4>
<p>因为切片是动态的，使用append可以往里增加元素，而使用copy可以复制切片A的内容到切片B上。</p>
<p>append的用法：</p>
<p><code>append</code>函数可以为一个切片一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，<code>append</code>函数都会帮我们自动处理。</p>
<pre><code class="language-go">slice:=[]int{1,2,3,4,5}
slice=append(slice,7,8,9)//可以一次加一个元素 也可以增加多个 如果容量不够，底层会自动扩容增
//注意调用append之后一定要接收返回值，否则没有实现切片的元素增加

</code></pre>
<p><strong>通过...可以在用同一纬度的切片来append：</strong></p>
<pre><code class="language-go">slice1 := []int{1, 2, 3}
slice2 := make([]int, 10)
slice2 = append(slice2, slice1...) //就是这一行，实现将同维度的切片append到另一个切片上
fmt.Println(slice2)
//output
[0 0 0 0 0 0 0 0 0 0 1 2 3]

</code></pre>
<p><strong>append函数的简单实现</strong></p>
<pre><code>func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}

</code></pre>
<p><strong>copy函数用法</strong></p>
<p>Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst). 如果dst和src的其中一个长度为0，则没有复制任何元素。copy后，dst和src是不一样的内存，不存在共享。</p>
<pre><code class="language-go">copy(destination,source)
dst_slice:=make([]int,len,cap)
src_slice:=[]int{1,2,3,4,5}
copy(dst_slice,src_slice)

</code></pre>
<p>切片的数据结构包含三个基本元素，1.指向数组的指针，2.切片的长度len，3.切片的容量cap</p>
<p>多个切片是可以同时指向同一个数组的，修改其中一个切片会影响其他的切片：</p>
<pre><code class="language-go">src_slice := []int{7, 7, 7, 7, 7}
dst_slice := src_slice
dst_slice[2] = 9
fmt.Println(src_slice, dst_slice)
//输出 [7 7 9 7 7] [7 7 9 7 7]

</code></pre>
<p>除了通过make，或者自己给定元素的方式来初始化外，其他<strong>通过别的数组、切片来初始化切片</strong>，都会使得<strong>新的切片</strong>与别的切片或数组<strong>共享同一片内存</strong>，数据是共用的（初始化时，新的切片底层的数据结构其实直接就是等号右侧切片的副本，复制了它的地址、长度和大小信息）。</p>
<pre><code class="language-go">arr:=[5]int{1,2,3,4,5}
slice:=arr[:3]
arr[2]=20
fmt.Println(slice,arr)
//输出 [1 2 20] [1 2 20 4 5]

</code></pre>
<p>但如果某个切片一旦需要扩容，复制旧的元素到新的空间后，则是新的内存空间，不再影响之前的数组内存。</p>
<pre><code class="language-go">arr:=[5]int{1,2,3,4,5}
slice:=arr[:3]
slice=append(slice,7,8,9,10,11,12)
arr[2]=20
fmt.Println(slice,arr)
//输出 [1 2 3 7 8 9 10 11 12] [1 2 3 4 5]

</code></pre>
<p>切片名其实就是一个地址，是底层指向的数组元素的首地址，对切片名不需要用&amp;取地址，而对数组名则需要&amp;：</p>
<pre><code class="language-go">arr:=[5]int{1,2,3,4,5}
slice:=arr[:3]
arr[2]=20
fmt.Printf(&quot;arr address:%p slice address: %p\n&quot;,&amp;arr,slice)
//输出arr address: 0xc0000240c0 slice address: 0xc0000240c0
//可以看到地址是相同的，表明确实是引用同一内存空间

</code></pre>
<h4 id="一种声明切片和数组的方法">一种声明切片和数组的方法</h4>
<pre><code class="language-go">a:=[...]string{3:&quot;hello&quot;,9:&quot;world&quot;}
b:=[]strign{3:&quot;hello&quot;,9:&quot;world&quot;}
//指定数组或切片下标对应的元素值

</code></pre>
<h4 id="new和make的区别">new()和make()的区别</h4>
<p>看起来二者没有什么区别，都在<strong>堆上分配</strong>内存，但是它们的行为不同，适用于不同的类型。</p>
<ul>
<li>new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的<strong>内存地址</strong>:这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。</li>
<li>make(T) 返回一个<strong>类型</strong>为 T 的初始值，它<strong>只适用于3种内建的引用类型</strong>:切片、map 和 channel</li>
</ul>
<h4 id="从字符串生成切片">从字符串生成切片</h4>
<p>字符串本质上是个字节数组，根据字符的不同，对应的字节数不一样，例如ascii码对应一个字节，utf8一个字符可能对应3个或4个字节（ UTF-8 的是一种变长编码规则，从 1 到 4 个字节不等。 ）</p>
<pre><code class="language-go">var r []byte
//比较适合ascii字符串，用汉字的话输出会乱码
var s string = &quot;I love you&quot;

r = append(r, s...) //...有解包的含义

for _, v := range r {
fmt.Printf(&quot;%c &quot;, v)
}

</code></pre>
<p>go语言中的<strong>字符串是不可变对象</strong>，不能通过str[idx]='h'这样的形式来修改，编译不过。</p>
<h5 id="byte切片和string类型互转">byte切片和string类型互转</h5>
<p>byte其实就是uint8，一个字节</p>
<p>string可以和byte的切片转换</p>
<p>1,string 转为[]byte</p>
<p>var str string = &quot;test&quot;</p>
<p>var data []byte = <strong>[]byte(str)</strong></p>
<p>2,byte转为string</p>
<p>var data [10]byte</p>
<p>byte[0] = 'T'</p>
<p>byte[1] = 'E'</p>
<p>var str string = <strong>string(data[:])</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言类型]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-lei-xing/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-lei-xing/">
        </link>
        <updated>2022-08-28T08:45:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go语言的指针类型">Go语言的指针类型</h3>
<p>声明指针：</p>
<pre><code class="language-go">var ptr *int
var p_array [5]*int
</code></pre>
<h4 id="指针数组">指针数组</h4>
<pre><code class="language-go">const max = 3

func main() {
    number := [max]int{5, 6, 7}
    var ptrs [max]*int //指针数组
    //将number数组的值的地址赋给ptrs
    for i, x := range number {
        ptrs[i] = &amp;x
    }
    for i, x := range ptrs {
        fmt.Printf(&quot;指针数组：索引:%d 值:%d 值的内存地址:%d\n&quot;, i, *x, x)
    }
}
//输出如下
指针数组：索引:0 值:7 值的内存地址:824634204304
指针数组：索引:1 值:7 值的内存地址:824634204304
指针数组：索引:2 值:7 值的内存地址:824634204304
</code></pre>
<p>上述写法中，之所以值和地址都一样，是因为这种写法中，每次往指针数组里存的都是局部变量x的地址和值，到最后一次循环的时候x=7，所以最终结果如输出结果一样。<strong>与range一起使用来对指针数组赋值时尤其要注意这点</strong>。</p>
<p>正确写法应为：</p>
<pre><code class="language-go">const max = 3

func main() {
    number := [max]int{5, 6, 7}
    var ptrs [max]*int //指针数组
    //将number数组的值的地址赋给ptrs
    for i := 0; i &lt; max; i++ {
        ptrs[i] = &amp;number[i]
    }
    for i, x := range ptrs {
        fmt.Printf(&quot;指针数组：索引:%d 值:%d 值的内存地址:%d\n&quot;, i,*x, x)
    }
}
</code></pre>
<h4 id=""></h4>
<h4 id="指向指针的指针">指向指针的指针</h4>
<p>声明方式</p>
<pre><code>var ptr **int
</code></pre>
<h4 id="函数的指针形参">函数的指针形参</h4>
<pre><code class="language-go">func myfun(ptr *int) [return type]{/* code */}
</code></pre>
<hr>
<h3 id="go语言的结构体">Go语言的结构体</h3>
<p>声明结构体</p>
<pre><code>type mystruct struct{
	member1 type
	member2 type
	...
	member3 type
}
</code></pre>
<p>初始化结构体</p>
<pre><code>s1:=mystruct{val1,val2,val3...}

key value形式初始化
s2:=mystruct{member1:val1,member2:val2...}
忽略的成员字段为零值
s3:=mystruct{member1:val1}
</code></pre>
<p>访问结构体的成员</p>
<p>通过句号运算符来访问</p>
<pre><code>s1:=mystruct{1,2,3}
s1.member2=6
fmt.Println(s1.member1)//输出1
</code></pre>
<p>结构体的指针</p>
<pre><code>var sp *mystruct
sp1:=&amp;s1
//指针访问结构体成员也是句号运算符：
//s1.member1和sp.member1等价 这点和C++有所区别

</code></pre>
<p><strong>结构体成员的可见性（public和private）</strong></p>
<p>首字母大写的是public成员，小写的是private成员</p>
<p><strong>这里的可见性是包与包之间的可见性</strong>，包A中有个结构体S，包B中想要访问S的成员的话，必须S中的成员变量名是首字母大写的</p>
<p>当要将结构体对象转换为 JSON 时，对象中的属性首字母必须是大写，才能正常转换为 JSON。</p>
<pre><code class="language-go">type Person struct {
　　　Name string　　　　　　//Name字段首字母大写
　　　age int               //age字段首字母小写
}

func main() {
　　person:=Person{&quot;小明&quot;,18}
　　if result,err:=json.Marshal(&amp;person);err==nil{  //json.Marshal 将对象转换为json字符串
　　　　fmt.Println(string(result))
　　}
}

</code></pre>
<p>输出：</p>
<pre><code class="language-go">{&quot;Name&quot;:&quot;小明&quot;}    //只有Name，没有age

</code></pre>
<p>那这样 JSON 字符串以后就只能是大写了么？ 当然不是，可以使用 tag 标记要返回的字段名。</p>
<pre><code class="language-go">type Person  struct{
   　　Name  string   `json:&quot;name&quot;`　  //标记json名字为name　　　
   　　Age    int     `json:&quot;age&quot;`
   　　Time int64    `json:&quot;-&quot;`        // 标记忽略该字段

}

func main(){
　　person:=Person{&quot;小明&quot;,18, time.Now().Unix()}
　　if result,err:=json.Marshal(&amp;person);err==nil{
　　　fmt.Println(string(result))
　　}
}

</code></pre>
<p>控制台输出：</p>
<pre><code class="language-go">{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:18}

</code></pre>
<p><strong>结构体嵌套，实现继承关系</strong></p>
<pre><code class="language-go">type s1 struct{
	radius float32
}
type s2 struct{
	s1 //匿名父类
	height float32
}

func main(){
	mystruct:=s2{s1{radius:1.23},5.666}
	fmt.Println(mystruct.radius,mystruct.height)
}
//output 1.23 5.666

</code></pre>
<p>在子结构体中使用匿名父类，实现继承关系，子结构体可访问父类中的所有成员，父类如同在子结构体中展开了一般。<strong>子结构体不仅继承了父类的所有成员，也继承了父类的所有方法（相当于子类也实现了这些方法一样）</strong>，子结构体的对象都可以访问父类的方法和成员。</p>
<p><code>s2{s1{radius:1.23},5.666}</code>这里的父类s1的初始化很像C++中子类构造函数指定如何初始化父类一样:</p>
<pre><code class="language-go">type s1 struct{
	radius float32
}
type s2 struct{
	s1
	height float32
}

func main(){
	my_struct:=s2{s1:s1{123},height:456} //这个是指定字段初始化
    my_struct2:=s2{s1{123},456} //这个是按照s2声明的成员顺序初始化
}

</code></pre>
<p>如果父类与子结构体有<strong>相同的字段</strong>，则访问父类中的同名字段时，<strong>需要加上父类的类名</strong>，而子结构体的则直接访问：</p>
<pre><code class="language-go">type s1 struct{
	same string
}
type s2 struct{
	s1
	same string
}
func main(){
	mystruct:=s2{}
	mystruct.s1.same=&quot;hello&quot;
	mystruct.same=&quot;world&quot;
	fmt.Println(mystruct.s1.same,mystruct.same) //output hello world
}

</code></pre>
<hr>
<h3 id="go语言的范围range">Go语言的范围（range）</h3>
<p>关键字range在go中是用来迭代数组、切片、channel和map元素（可迭代对象）的，对于数组和切片而言，得到是索引和元素的值，而对于map而言，得到的是键值对</p>
<pre><code class="language-go">//example1
slice:=[]int{1,2,3,4,5}
sum：=0
for idx,_:=range slice{
	sum+=slice[idx]
}
fmt.Println(sum) //output 15

//example2
m := map[string]string{&quot;a&quot;: &quot;hello&quot;, &quot;b&quot;: &quot;world&quot;}
for k, v := range m {
    fmt.Printf(&quot;key: %s value: %s &quot;, k, v)
} //output key: a value: hello key: b value: world

</code></pre>
<p>range还可用于迭代字符串，<strong>返回每个字符的下标和该字符对应unicode的值(也即一个rune类型的值)</strong></p>
<pre><code class="language-go">str := &quot;你好&quot;
for idx, val := range str {
fmt.Println(idx, val)
}
// output 
//0 20320
//3 22909
for idx:=range str{
    fmt.Println(idx)
}//output 0 3 返回的是每个字符的索引，由于你好两个字是三个字节为单位，所以返回的是0，3
//对于数组和切片而言，这种写法都是返回的下标索引

</code></pre>
<p>通过range实现范围for也可以不需要使用range的返回值：</p>
<pre><code class="language-go">slice:=[]int{1，2，3，4，5}
count:=0
for range slice{
	count++
}
fmt.Println(count) //输出5

</code></pre>
<hr>
<h3 id="go语言的map类型">Go语言的map类型</h3>
<p>map是<strong>无序的</strong>键值对存储容器，底层使用<strong>hash_table实现</strong>，与C++的map有区别，与python的字典相似，遍历map时并不知道键值对谁先谁后。</p>
<p>声明方式：</p>
<pre><code class="language-go">var my_map map[key_type] value_type//这种方式不初始化的话声明了一个nil的map，无法进行键值对的存储
my_map:=make(map[key_type]value_type)//这种方式不初始化虽然是空map，但是可以进行键值对的插入

</code></pre>
<p><strong>通过make创建map时，已经完成了初始化</strong>，是一个空map；此外，下面这种方式也是初始化了：</p>
<pre><code class="language-go">another_map:=map[int]string{1:&quot;hhh&quot;,2:&quot;www&quot;}
my_map:=map[int]string{}//空map，但初始化了，可以存储kv
my_map[1]=&quot;helloworld&quot;//此时和C++的字典使用方法一样，已存在的key则会赋予新的值，不存在的key则生成一个新的kv对，存入map中

</code></pre>
<p>但单纯只是声明的话，得到的是一个nil，无法进行存储：</p>
<pre><code class="language-go">var map1 map[int]string // nil
map1[1]=&quot;helloworld&quot; //runtime error

</code></pre>
<p>可以通过下面的方法取判断map中是否存在某个key，如果不存在，则通过下标访问符得到的是个空值：</p>
<pre><code class="language-go">my_map := make(map[int]string)
my_map[1] = &quot;helloworld&quot; //插入kv对
fmt.Println(my_map)
v1 := my_map[2] //因为key 2不存在，v1是一个value类型的空值=&quot;&quot;
if v1 == &quot;&quot; {
fmt.Println(&quot;empty key 2&quot;)
}
fmt.Println(my_map)
_, exists := my_map[3] //_是键值对的value，这里不使用，exists是一个bool类型，map中有该key则为true，否则为false
if exists {
fmt.Println(&quot;key 3 exists&quot;)
} else {
fmt.Println(&quot;key 3 doesn't exists&quot;)
}
fmt.Println(my_map)
//output:
//map[1:helloworld]
//empty key 2
//map[1:helloworld]
//key 3 doesn't exists
//map[1:helloworld]

</code></pre>
<p>在C++中，map通过中括号的访问会新增kv对或者修改key对应的value值，而在上述的代码中，两次通过[]获取map中的元素，都<strong>没有增加map中新的kv对</strong>，这与C++是不同的。C++的结果如下：</p>
<pre><code class="language-c++"> #include&lt;map&gt;
 #include&lt;iostream&gt;
 #include&lt;string&gt;
 int main(){
         std::map&lt;int,std::string&gt; my_map;
         std::cout&lt;&lt;my_map[1];
         std::cout&lt;&lt;my_map.size()&lt;&lt;std::endl;
         if(my_map[1]==&quot;&quot;)
                 std::cout&lt;&lt;&quot;key 1 == empty&quot;&lt;&lt;std::endl;
}//output
//1
//key 1 == empty

</code></pre>
<p>对map的range for循环</p>
<pre><code class="language-go">my_map:=map[string]string{&quot;hello&quot;:&quot;world&quot;,&quot;nihao&quot;:&quot;dajiahao&quot;}
for k,v:=range my_map{ //kv分别为键和值
	/* code */
}
for k:=range my_map{  //k 是key
	/* code */
}

</code></pre>
<h4 id="delete函数">delete函数</h4>
<p>delete函数用于删除map中的元素，参数为map和想要删除的key</p>
<pre><code class="language-go">my_map1:=map[string]string{&quot;hello&quot;:&quot;world&quot;,&quot;nihao&quot;:&quot;dajiahao&quot;}
delete(my_map1,&quot;hello&quot;)
fmt.Println(my_map1)
//output
//map[nihao:dajiahoa]

</code></pre>
<hr>
<h3 id="go语言类型转换">Go语言类型转换</h3>
<p>类型强制转换（显式）和C++的写法很像</p>
<pre><code class="language-go">type(expression)
//example
var i1 int32=5
var i2 int32=10
f1:=float32(i1)/float32(i2)  //0.5

</code></pre>
<p>go<strong>不支持类型隐式转换</strong></p>
<pre><code class="language-go">var f1 float32=0.1
var f2 float64=0.2
res:=f1/f2 //wrong msg: invalid operation: mismatched types float64 and float32
//除非 res:=f1/float32(f2)才能过编译

</code></pre>
<hr>
<h3 id="go语言接口类型">Go语言接口类型</h3>
<p>接口和直观上的理解一样，很多内置的函数，或者自己编写的函数，可能存在对某个类调用同名的方法（形参、返回类型都一样），就可以实现多态。此时，为一个类型实现接口的方法，在后续别的地方使用时，就可以实现回调。</p>
<p>接口类型是声明了一系列共性方法的一种类型，声明方式为：</p>
<pre><code class="language-go">type my_interface interface{
	func1(params) [return type]
	func2(params) [return type]
}

</code></pre>
<p>任何其他类型实现了上述的这些方法（func_i），则是实现了这个接口：</p>
<pre><code class="language-go">func(ms mystruct) func1(){   //自定义结构体类型mystruct
	/* code */    
}

func(ms newStruct) func1(){ //自定义结构体类型newStruct
	/* code */
}
//其实和之前函数教程中写某个类的方法的方式是一样的，本质上都是一样的

</code></pre>
<p>上述的代码中，两个自定义的类都实现了接口中的func1函数，通过接口对象来调用这个函数的过程如下</p>
<pre><code class="language-go">var inter my_interface
inter=new(mystruct)
inter.func1()  //调用mystruct实现的函数
inter=new(newStruct)
inter.func1()  //调用newStruct实现的函数

</code></pre>
<p>这种方式<strong>有点像基类指针指向派生类</strong>，而接口中的函数相当于虚函数一样，然后通过接口对象（基类）访问自定义的类（派生类）实现的方法（虚函数）。但使用这种方法的前提是，自定义的类（派生类）<strong>必须把接口中所有声明的函数都实现</strong>了，不然无法过编译（以这里的例子而言，还需实现func2函数）。</p>
<p><strong>接口类型的变量可以保存任何实现了该接口的类型的值</strong>，自定义的类型实现接口中的方法可以是值也可以是指针作为接收者，而没有硬性要求必须全为值或全为指针接收者，但只要有一个方法是指针接收者实现的，则在赋给接口变量的时候，就必须取址：</p>
<pre><code class="language-go">type MyInterface interface {
	read()
	write()
}

func (m MyStruct) read() {  //这里是值接收者
	fmt.Println(m.radius)
}
func (m *MyStruct) write() { //这里是指针接收者
	fmt.Println(m.radius)
}
func main() {
	ms := &amp;MyStruct{1.2, 2.4}  //ms是指针
	var inter MyInterface
	inter = ms //因为有指针接收者实现的方法，则赋给接口对象的必须是个指针
	inter.read()
	inter.write()
}

</code></pre>
<p><strong>接口本身也是一个值，它可以看作一个包含具体值和类型的元组（value,type）</strong>，这里的value指的是赋给接口的对象的值，而type即为该对象的类型，<strong>可用于做类型断言（下面的笔记有写）</strong>。接口对象调用接口中的方法实际上调用的就是底层对象value的方法，如上main函数中的inter。</p>
<p>如果将变量A通过值赋给接口对象，那么接口对象底层的具体值是个A的副本；而如果是通过指针赋给接口对象，则接口底层对象是A的指针，此时接口对底层具体值的修改会影响变量A本身。</p>
<p>假设类型A使用指针接收者实现了接口，<strong>如果赋给接口对象inter的是一个A的nil指针，这时候接口对象并不为nil</strong>，只是底层的value是个nil指针，类型type是*A。当然这是如果inter调用了方法，可能出现panic，可以通过如下方式进行保护：</p>
<pre><code class="language-go">type I interface {
	M()
}

type T struct {
	S string
}

func (t *T) M() {
	if t == nil {
		fmt.Println(&quot;&lt;nil&gt;&quot;)
		return
	}
	fmt.Println(t.S)
}
func main(){
	var tp *T //这里的tp是类型T的nil指针，
	var inter I
	inter=tp //接受了类型T的nil指针
	inter.M() //函数M进入if语句块，保证程序不panic
}

</code></pre>
<p><strong>nil的接口</strong>：<code>var inter MyInterface</code>这时inter为一个nil接口，既没有保存底层具体值value，也没有类型type信息，不能对其进行方法调用，例如此时的inter.func1()是错误的。</p>
<p>由上所述，这种实现接口方法的方式和为自定义类添加方法的方式是一样的，所以通过类对象自己访问方法也是可以的，这时候就不需要所有的接口方法都实现：</p>
<pre><code class="language-go">ms:=mystruct{}
ms.func1() //这样，即使没有实现func2，照样可以运行

</code></pre>
<p>若实现接口方法不是通过类型指针实现的，则通过接口访问类型方法的方式为：</p>
<pre><code class="language-go">func(ms mystruct) func1(){
	/* code */
}
var inter my_interface=mstruct{}

</code></pre>
<p>若用到了类型指针，则访问方式为：</p>
<pre><code class="language-go">func(ms *mystruct) func1(){
	/* code */
}
var inter my_interface=&amp;mstruct{}

</code></pre>
<p>两者的区别为，用到指针了，则将类型对象赋给接口对象时<strong>需要取址&amp;</strong>。</p>
<p>接口对象可以接受值或者指针赋值，用指针赋值永远不会错，<strong>推荐写代码时都取址</strong>，避免多余记忆点。</p>
<p>接口还可以组合：</p>
<pre><code class="language-go">type outer_inter1 interface {
	read()
}

type outer_inter2 interface {
	write()
}

type my_interface interface {
	outer_inter1
	outer_inter2
}

func (m mystruct) read() {
	fmt.Println(&quot;mystruct running read function from interface&quot;)
}

func (m mystruct) write() {
	fmt.Println(&quot;mystruct running write function from interface&quot;)
}

func main(){
	var inter my_interface
	inter = &amp;mystruct{}
	inter.read()
	inter.write()
}
//output
//mystruct running read function from interface
//mystruct running write function from interface

</code></pre>
<p>组合的接口看起来难理解，可以直接把它看作多个接口的展开，一个组合的接口就等于是声明了其中组分接口的每个方法（因此，上面的代码中同时实现了read和write方法）。</p>
<p>在结构体中，可以通过使用匿名结构体进行继承，继承父类的所有方法和成员，因此，<strong>如果父类实现了接口，则相应的子结构体也实现了接口</strong></p>
<pre><code class="language-go">type s1 struct{
}
type s2 struct{
	s1
}
type myinter interface{
	helloworld()
}
func(s s1) helloworld(){
	fmt.Println(&quot;helloworld&quot;)
}
func main(){
	var inter myinter
	myinter=new(s2)
	myinter.helloworld() //output helloworld
}

</code></pre>
<p><strong>interface{}叫做空接口</strong>，<strong>所有类型都实现了空接口</strong>，所以空接口实例化的对象可以承载任何对象类型。因此，使用interface{}作为函数的形参，可以接收所有的类型对象，然后再对接收的对象进行类型断言，实现相应的功能。<strong>这个特性可用于实现go语言的多态。</strong></p>
<p>声明一个空接口：<code>var inter interface{}</code></p>
<pre><code class="language-go">func universe(inter interface{}) string {
	if _, ok := inter.(string); ok {
		return &quot;oh yea&quot;
	} else {
		return &quot;not good&quot;
	}

}
func main(){
	b := &quot;hhh&quot;
	c := 132
	fmt.Println(universe(b))
	fmt.Println(universe(c))
}
//output 
//oh yea 
//not good

</code></pre>
<hr>
<h3 id="go语言的断言type-assertion">Go语言的断言（type assertion）</h3>
<p>接口除了像上一节中一样，还有一种方式也是接口，但更像是一种容器一样：</p>
<pre><code class="language-go">var inter interface{}
inter=123 //可以是任何一种类型
fmt.Println(inter) // output 123

</code></pre>
<p>通过接口，可以进行断言，进行接口对象所承载的类型的判断，</p>
<p>语法：<code>val,ok:=inter.(type)</code>，val是inter承载类型对象的值，ok为bool值，表示是否是type类型。（<strong>安全断言</strong>）</p>
<p><strong>不安全断言</strong>：<code>val:=inter.(type)</code>，这种情况下，如果断言失败，程序会panic</p>
<pre><code class="language-go">var inter interface{}
inter=123
if val,ok:=inter.(int);ok{  //在本例中，val=123 ok=true
	fmt.Println(val) 
}  
//output 123

</code></pre>
<p><strong>interface{}叫做空接口</strong>，<strong>所有类型都实现了空接口</strong>，所以空接口实例化的对象可以承载任何对象类型，如下所示。这种接口变量可以形成接口数组/切片：</p>
<pre><code class="language-go">var inter_slice []interface{}
inter_slice=append(inter_slice,123,&quot;nihao&quot;,[]int{1,2,3},map[int]string{1:&quot;hello&quot;,2:&quot;world&quot;})
fmt.Println(inter_slice)
for _, element := range inter_slice {
    if _, ok := element.(int); ok {
        fmt.Println(&quot;find int element&quot;)
    }
}//output
//[123 nihao [1 2 3] map[1:hello 2:world]]
//find int element

</code></pre>
<p>像上一节中接口类型的用法，也可以用来作类型判断，有种判断基类指针指向的是什么派生类类型的味道：</p>
<pre><code class="language-go">type my_inter interface{
	read()
}

func(m mystruct) read(){
	fmt.Println(&quot;helloworld&quot;)
}

func main(){
	var inter my_inter=mystruct{}
	if _,ok:=inter.(mystruct){
		fmt.Println(&quot;it's mystruct&quot;)
	}
}//output it's mystruct

</code></pre>
<p>搭配type switch，可用于判断类型，inter.(type)只能搭switch形成type switch语句：</p>
<pre><code class="language-go">var inter my_interface
inter = &amp;mystruct{}
switch inter.(type) {
case *mystruct:
fmt.Println(&quot;it's mystruct&quot;)
}//output it's mystruct

</code></pre>
<hr>
<h3 id="go语言rune类型">Go语言rune类型</h3>
<p>rune类型其实就是int32，源码中是int32的别名，常用来处理unicode，因为unicode一般有三个字节组成一个字符，所以一个rune就可以对应一个unicode，而这个rune其实就是该字符对应的编码值：</p>
<pre><code class="language-go">str := &quot;nihao你好&quot;
fmt.Println(len(str))
fmt.Println(len([]rune(str)))
for _, val := range []rune(str) {
fmt.Println(val)
}
//output
11  //字符串对应的字节数 11
7   //rune切片的长度 7=nihao(5)+你好(2)
110
105
104
97
111
20320 //&quot;你&quot;的编码值
22909 //&quot;好&quot;的编码值

</code></pre>
<p>从例子中可以看到，其实rune就是每个字符的对应的编码值，因为其本质就是一个int32，然后可以再根据这个编码值进行编码，得到相应的字符：</p>
<pre><code class="language-go">output := make([]byte, 20)
utf8.EncodeRune(output, 20320)
fmt.Println(string(output))
//output 你

</code></pre>
<hr>
<h3 id="go语言map类型">Go语言map类型</h3>
<pre><code class="language-go">var m map[int]string
m2:=map[int]string{1:&quot;hello&quot;}

</code></pre>
<p>只要实现了=号运算符的类型，都可以作为map的键类型，例如integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays。</p>
<p><strong>而切片不能作为键类型，因为切片是没有实现=号运算符的。</strong></p>
<p>和切片一样，map拥有底层数据结构的引用，如果将map传参给函数，其实是按照引用进行了传递，在函数内的修改会导致传递的map发生变化：</p>
<pre><code class="language-go">func changeMap(m map[int]string) {
	for k := range m {
		m[k] = &quot;changed&quot;
	}
}
func main(){
	m1 := map[int]string{2: &quot;hello&quot;}
	fmt.Println(m1)
	changeMap(m1)
	fmt.Println(m1)
}
//output
map[2:hello]
map[2:changed]

</code></pre>
<p>由于map是引用传递，所以所有涉及到赋值、参数传递的行为都和切片的类似，例如将map1赋值给map2，然后对map2进行修改，map1的值也相应发生了变化：</p>
<pre><code class="language-go">m1 := map[int]string{2: &quot;hello&quot;}
fmt.Println(m1)
m2 := m1
fmt.Println(m2)
m2[2] = &quot;world&quot;
fmt.Print(m1, m2)
//output
map[2:hello]
map[2:hello]
map[2:world] map[2:world]

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言控制流]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-kong-zhi-liu/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-kong-zhi-liu/">
        </link>
        <updated>2022-08-28T08:44:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="if条件语句">if条件语句</h3>
<p>语法与C++一样，要注意的是：</p>
<p>1.条件不需要用小括号括起来</p>
<p>2.即使只有一条执行语句，也要有大括号，左括号必须与if、else、else if关键字同行</p>
<p>3.if的条件判断语句可以引入声明，声明的对象只在该if语句块中可见（该语句块中的多个if、else分支均可见），声明与条件判断<strong>用分号</strong>分隔</p>
<p>4.<strong>if语句的判断条件必须是布尔值</strong>，不能够是其他类型，也即不能像C++那样：非零值为true，零值为false。</p>
<pre><code class="language-go">if a:=10; a&gt;1{
	fmt.Print(a)
} else {
	fmt.Print(&quot;111&quot;)
}
</code></pre>
<hr>
<h3 id="switch语句">switch语句</h3>
<p>基本语法与C++一致，但<strong>每个case分支都默认加了break</strong>，不需手动添加。如果匹配了一个case后还想继续往下找case匹配，那么需要添加<strong>fallthrough</strong>关键字。（在break逻辑上刚好与C++相反的除了方式）</p>
<p>由于Go会给每个分支默认加上break，本质上只要没有指定fallthrough，执行完一个分支后switch语句块就结束了，所以在分支中显式的写出break和不写是没有区别的，switch语句块都会退出，因此<strong>显式给出的break，并不会退出switch语句块所在的循环。</strong></p>
<p>如果想要在switch中break掉外层的循环，可以<strong>给循环语句块加上label</strong>后，然后<strong>break label</strong>，这个label就是该循环语句的名字，<strong>label的下一行必须为循环语句</strong>，也即下一行必须紧接的是for：</p>
<pre><code class="language-go">Loop:
	for i := 0; i &lt;= 9; i++ {
		fmt.Println(&quot;In loop&quot;, i)
		switch {
		case i == 5:
			fmt.Println(&quot;Hit switch&quot;)
			break Loop
		}
	}
//output
In loop 0
In loop 1
In loop 2
In loop 3
In loop 4
In loop 5
Hit switch
</code></pre>
<p>这种通过label来跳出循环的，<strong>内部可跨多层跳出外层循环</strong>，具体是：</p>
<pre><code class="language-go">Loop:
	for {
		for i := 0; i &lt;= 9; i++ {
			fmt.Println(&quot;In loop&quot;, i)
			switch {
			case i == 1:
				fmt.Println(&quot;Hit switch&quot;)
				break Loop
			}
		}
	}
//output
In loop 0
In loop 1
Hit switch
</code></pre>
<p><strong>Label指向/代表的是其后紧跟的语句块或语句</strong>，一个label可以是一个if、for等语句块，也可以是一条语句，例如<code>fmt.Println(&quot;helloworld&quot;)</code>。</p>
<p>continue也可以后接一个label：</p>
<pre><code class="language-go">func main() {
Loop:
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;before continue&quot;)
		continue Loop
		fmt.Println(&quot;after continue&quot;)
	}
}//这样after continue就不会打印出来
</code></pre>
<p>一个case分支可以<strong>判断多个值</strong>进行匹配，<strong>用逗号进行分隔：</strong></p>
<p><code>case val1,val2,val3: </code></p>
<pre><code class="language-go">switch var1 {
    case val1:
        ...
    case val2:
        ...
    	fallthrough
    default:
        ...
}//var1 可以是任意类型的变量，表达式。val1、val2可以是值也可以是表达式，但必须为同类型的值
</code></pre>
<p>没有写fallthrough的时候分支就好像一个断点一样，执行到下一个断点就结束该switch语句</p>
<p><strong>fallthrough后的case不会进行匹配</strong>（ fallthrough 不会判断下一条 case 的表达式结果是否为 true ），直接执行语句：</p>
<pre><code class="language-go">switch a {
case 1, 23, 10:
fmt.Println(&quot;case1&quot;)
fallthrough
case 20:
fmt.Println(&quot;case2&quot;)
default:
fmt.Println(&quot;default case&quot;)
}// 输出 case1 case2 
</code></pre>
<p>switch语句也可以搭配声明语句一起使用：</p>
<pre><code class="language-go">map1 := map[string]string{}
map1[&quot;hello&quot;] = &quot;world&quot;
switch a,_:=map1[&quot;hello&quot;];a{
	case &quot;world&quot;:
		fmt.Println(&quot;hello-&gt;world&quot;)
	case &quot;hello&quot;:
		fmt.Println(&quot;hello-&gt;hello&quot;)
	default:
		fmt.Println(&quot;no needed &quot;)
}
//output
hello-&gt;world
</code></pre>
<p>甚至switch后不需要跟变量，只要case后跟了一个布尔运算表达式即可：</p>
<pre><code class="language-go">switch {
case true:
fmt.Println(&quot;hello-&gt;world&quot;)
case false:
fmt.Println(&quot;hello-&gt;hello&quot;)
default:
fmt.Println(&quot;no needed &quot;)
}
//output
hello-&gt;world
</code></pre>
<h4 id="type-switch">Type Switch</h4>
<p>switch语句可用于type-switch语句来判断某个interface变量中实际存储的变量类型</p>
<p><strong>type-switch中不能使用fallthrough</strong></p>
<pre><code class="language-go">switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* 你可以定义任意个数的case */
    default: /* 可选 */
       statement(s);
}

</code></pre>
<pre><code class="language-go">var b interface{}
switch i := b.(type) {
case nil:
fmt.Println(&quot;case1&quot;, i)
case int:
fmt.Println(&quot;case2&quot;)
default:
fmt.Println(&quot;default case&quot;)
}//输出case1 &lt;nil&gt;

</code></pre>
<p><strong>上述的i:=b.(type)，如果在switch语句中匹配到了某个类型，则i是这个类型的值；而如果都没有匹配到，例如最终到了default分支，则i是b的类型：</strong></p>
<pre><code class="language-go">func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)
	case string:
		fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))
	default:
		fmt.Printf(&quot;I don't know about type %T!\n&quot;, v)
	}
}

func main() {
	do(21)
	do(&quot;hello&quot;)
	do(true)
}
//output
Twice 21 is 42
&quot;hello&quot; is 5 bytes long
I don't know about type bool!

</code></pre>
<p>其实上述这个type switch语句，还是根据i.(type)进行了分支判断，只不过v根据分支判断有不同的结果。</p>
<hr>
<h3 id="select语句">select语句</h3>
<p>select语句可以看成是用于通信的switch语句，有点APUE中select函数的意思</p>
<pre><code class="language-go">select {
    case communication clause  :
       statement(s);      
    case communication clause  :
       statement(s);
    /* 你可以定义任意数量的 case */
    default : /* 可选 */
       statement(s);
}

</code></pre>
<p>特点：</p>
<p>1.每个case都是一个通信语句</p>
<p>2.所有的channel表达式都会被求值、所有被发送的表达式也会被求值</p>
<p>3.如有某个通信（case）可执行，则只执行这个，其他的忽略</p>
<p>4.<strong>若有多个case满足条件，则会随机的选择一个case进行执行，其他的不会执行</strong></p>
<p>​	否则：<br>
​		1.如果有default分支，则执行该分支</p>
<p>​		2.若无default分支，则select语句会阻塞（循环等待），直到有通信可以运行，Go不会重新对channel和值进行求值。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = &lt;-c1:
         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)
      case c2 &lt;- i2:
         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)
      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
         if ok {
            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)
         } else {
            fmt.Printf(&quot;c3 is closed\n&quot;)
         }
      default:
         fmt.Printf(&quot;no communication\n&quot;)
   }    
}//输出 no communication

</code></pre>
<hr>
<h3 id="for循环">for循环</h3>
<p>Go语言的循环语句只有一个for语句，能够实现c++的条件循环、while循环相同的功能</p>
<pre><code class="language-go">for init;condition;post{

}//类似于C++中的for (int i =0;i&lt;100;i++)
for condition {

} //类似while (i&lt;100)
for {

} // 类似 while(1)

//也有范围for的用法
for key,value:=range oldMap{
	newMap[key]=value
}

for key:=range oldMap{
    fmt.Println(key)
} 
//通过这样range也可只取第一个返回值，不需要用下划线去忽略第二个返回值

</code></pre>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func main() {
        strings := []string{&quot;google&quot;, &quot;runoob&quot;}
        for i, s := range strings {
                fmt.Println(i, s)
        }
    
        numbers := [6]int{1, 2, 3, 5}
        for i,x:= range numbers {
                fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i,x)
        }  
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言基础知识]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-ji-chu-zhi-shi/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-ji-chu-zhi-shi/">
        </link>
        <updated>2022-08-28T08:44:22.000Z</updated>
        <content type="html"><![CDATA[<p>教程文档<br>
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</p>
<h1 id="go-tools">Go Tools</h1>
<h2 id=""><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165141795-1.png" alt="image" loading="lazy"></h2>
<h3 id="goroot-gopath目录">GOROOT、GOPATH目录</h3>
<p>GOROOT目录是go的安装目录，含有<strong>标准库</strong>的包；GOPATH是<strong>第三方库和开发的项目代码</strong>的目录（相当于工作区）。</p>
<p>GOPATH可以设置多个，go get下载的包会放置道第一个GOPATH目录下的src目录中。go install安装的包会放到GOPATH/bin下； 使用 go install时，在哪个**<code>GOPATH</code>**中找到了这个包，就会在哪个<code>GOPATH</code>下的bin目录生成可执行文件</p>
<p><strong>import查找包的顺序是先GOROOT，后GOPATH。</strong></p>
<p>假设引入下面的包</p>
<pre><code class="language-go">import &quot;Go-Player/src/chapter17/models&quot;
</code></pre>
<p>第一步：Go会先去<strong>GOROOT的src目录中</strong>查找，很显然它不是标准库的包，没找到。<br>
第二步：继续在<strong>GOPATH的src目录</strong>去找，准确说是GOPATH/src/Go-Player/src/chapter17/models这个目录。如果该目录不存在，会报错找不到package。在使用GOPATH管理项目时，需要按照GO寻找package的规范来合理地保存和组织Go代码。<br>
目前个人理解是$GOPATH/src下创建不同的目录，每个目录就是一个项目。</p>
<p><strong>GoLand中可以设置项目GOPATH，与全局GOPATH区分。</strong></p>
<hr>
<h3 id="go111module参数设置说明">GO111MODULE参数设置说明</h3>
<p>用环境变量 <code>GO111MODULE</code> 开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是 <code>auto</code>。</p>
<ul>
<li>
<p><code>GO111MODULE=off</code> 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</p>
<p>go在GOROOT和GOPATH中搜索所需的模块</p>
</li>
<li>
<p><code>GO111MODULE=on</code> 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 <code>go.mod</code> 下载依赖。</p>
<p>此时，即使在GOPATH下有模块，也不能导入，go只会在GOROOT中搜索</p>
</li>
<li>
<p><code>GO111MODULE=auto</code> 在 <code>$GOPATH/src</code> 外面且根目录有 <code>go.mod</code> 文件时，开启模块支持。</p>
</li>
</ul>
<p>在使用模块的时候，<code>GOPATH</code> 是无意义的，不过它还是会把下载的依赖储存在 <code>$GOPATH/src/mod</code> 中，也会把 <code>go install</code> 的结果放在 <code>$GOPATH/bin</code> 中。</p>
<p>模块的根目录和子目录所有的包组成一个模块，在根目录下存在go.mod文件，子目录会一直向上寻找go.mod。</p>
<p>模块路径指模块根目录的导入路径，是子目录路径的前缀</p>
<p>go.mod文件的第一行定义了模块路径，模块子目录都相对于该路径，若需要import子模块， <strong>直接导入go.mod中模块地址+子目录</strong> ，代码为：</p>
<p><code>import &quot;mymod/sub_mod&quot;</code></p>
<p>这个mymod是通过go mod init mymod指定的：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165209014-1.png" alt="image" loading="lazy"></figure>
<p>此时，mymod这个标识符就代表了模块路径，如果go.mod文件所在的目录下，有一个子模块test，则在go文件中的导入代码为：</p>
<p><code>import &quot;mymod/test&quot;</code></p>
<p>go.mod文件中会定义当前模块所需的依赖，以及可以排除和替换依赖：</p>
<pre><code class="language-go">module example.com/m 

require ( //模块所需依赖
    golang.org/x/text v0.3.0
    gopkg.in/yaml.v2 v2.1.0 
)

replace ( //替换依赖
    golang.org/x/text =&gt; github.com/golang/text v0.3.0
)
</code></pre>
<p>go.mod不用手写，可以用 <code>go mod init example.com/m</code> 生成 <code>go.mod</code> 的第一行，文件的剩余部分也不用担心，在执行 <code>go build</code>、<code>go test</code>、<code>go list</code> 命令时会根据需要的依赖自动生成 <code>require</code> 语句。</p>
<hr>
<h3 id="go语言结构">Go语言结构</h3>
<p>https://cloud.tencent.com/developer/doc/1101 go语言手册</p>
<p>基本的组成包含：</p>
<p>1.包声明</p>
<p>​	关键字 package</p>
<p>​	每个go文件的第一行都要声明该文件是哪个包，要进行包声明(e.x. package main)</p>
<p>​	package main 表示一个可独立执行的应用程序，每个go程序都包含一个main包（类似int main() 只有一个，程序的入口函数）</p>
<p>Go语言的代码通过<strong>包</strong>（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。**一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。**每个源文件都以一条<code>package</code>声明语句开始，这个例子里就是<code>package main</code>，表示该文件属于哪个包。</p>
<p>2.引入包</p>
<p>​	import 包名</p>
<p>​	类似python的import，引入包后使用包的函数和变量</p>
<p>​	可以import一个目录，或者目录中的目录都可以</p>
<p>3.函数</p>
<p>​	func main() {<br>
​	/* code */</p>
<p>​    }</p>
<p>​	main函数，程序的入口，要<strong>注意函数的左大括号一定要和函数名在同一行</strong>。</p>
<p>4.变量</p>
<p>5.语句与表达式</p>
<p>​	与python一样，句尾<strong>无需加分号</strong>，若想一行写多个语句，则需要加分号进行分割</p>
<p>6.注释</p>
<p><strong>Note：<strong>标识符（函数名、变量名等）如果首字母大写，表示该对象是全局可见的，是</strong>已导出</strong>的标识符，其他文件引入该包体后可以使用该标识符，相当于public；而如果是小写开头，则不可见，为<strong>未导出</strong>的标识符，相当于private，无法在包外被访问。</p>
<p><strong>文件名和包名没有直接关系，不需要一致。</strong></p>
<p><strong>同一目录下的多个go文件，只能有一个包名。</strong> import引用的是目录名，而不是包名，因此一个目录就代表了一个包， 对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</p>
<hr>
<h3 id="go语言关键字">Go语言关键字</h3>
<p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody>
</table>
<p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="go语言基本类型">Go语言基本类型</h3>
<p>Go语言支持<strong>复数</strong>类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<strong>strings包的api可用于处理字符串</strong></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody>
</table>
<p><strong>浮点数的相等比较是比较危险的，因为存在精度问题。</strong></p>
<p>尽量使用float64，因为float32的表示范围不是很大，在计算时累积后可能导致溢出，（ 因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差 ）</p>
<p>小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：</p>
<pre><code class="language-Go">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
</code></pre>
<p>用Printf函数的**%g参数打印浮点数**，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，<strong>使用%e（带指数）或%f的形式打印可能更合适</strong>。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>
<p>函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，<strong>因为NaN和任何数都是不相等的</strong>（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）：</p>
<pre><code class="language-Go">nan := math.NaN()
fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // &quot;false false false&quot;
</code></pre>
<h4 id="其他数字类型">其他数字类型</h4>
<p>以下列出了其他更多的数字类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>byte</strong> 类似 uint8</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>rune</strong> 类似 int32</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uint</strong> 32 或 64 位</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>int</strong> 与 uint 一样大小</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="变量">变量</h3>
<p>如果声明了一个<strong>局部变</strong>量，但<strong>没有使用</strong>（即使赋值了也不行，一定要使用），则会<strong>编译失败</strong>。。。</p>
<p>全局变量允许只声明不适用</p>
<h4 id="1普通声明变量的方式">1.普通声明变量的方式</h4>
<p><code>var name type</code></p>
<p>一次声明多个命令：</p>
<p><code>var name1,name2 int = 1,2</code></p>
<p>在变量声明时，若<strong>没有</strong>进行<strong>初始化</strong>，则<strong>默认为零值</strong>，对于不同的类型，零值的值不同：</p>
<ul>
<li>
<p>数值类型（包括complex64/128）为 <strong>0</strong></p>
</li>
<li>
<p>布尔类型为 <strong>false</strong></p>
</li>
<li>
<p>字符串为 <strong>&quot;&quot;</strong>（空字符串）</p>
</li>
<li>
<p>以下几种类型为 <strong>nil</strong> ，只有chan、interface、func、slice、map、pointer可直接与nil比较和用nil赋值。 ：</p>
<pre><code class="language-go">var a *int
var a []int
var a map[string] int
var a chan int
var a func(string) int
var a error // error 是接口
</code></pre>
</li>
</ul>
<h4 id="2也可通过初始化的对象来推测类型">2.也可通过初始化的对象来推测类型</h4>
<p><code>var name = &quot;helloworld&quot;</code></p>
<h4 id="3省略var通过声明这种不带声明格式的只能在函数体内出现短变量声明">3.省略var，通过:=声明（这种不带声明格式的，<strong>只能在函数体内出现</strong>）短变量声明</h4>
<p>声明变量+初始化</p>
<p>要注意这是一个声明语句，如果同一变量已经声明了，使用:=会编译失败，后续可用=进行赋值，修改变量的值</p>
<p><code>name:=1 </code></p>
<p><code>name2:=&quot;helloworld&quot;</code></p>
<p>正常来说，在同一个作用域中，是不允许对同一变量进行重复声明的，也即不允许redefinition的存在</p>
<p>在<code>:=</code>声明中，<code>v</code>即使已经声明了变量，也可以再对该变量进行一次短变量声明，但前提条件是：</p>
<ul>
<li>此声明与的现有声明在同一范围内<code>v</code> （如果<code>v</code>已经在外部范围中声明，则该声明将创建一个新变量§），</li>
<li>初始化中的对应值可分配给<code>v</code>和</li>
<li>**声明创建了至少一个其他变量。**也即必须同时声明了别的变量。</li>
</ul>
<p>所以以下这种情况是允许的：</p>
<pre><code class="language-go">a1,b1:=123,456
a1,b2:=777,999
</code></pre>
<p>上面第三点的反例：</p>
<pre><code class="language-go">a1,b2:=123,456
a1:=777 //wrong
</code></pre>
<p>这种重复声明的方式常见于获取函数多个返回值，例如获取错误信息：</p>
<pre><code class="language-go">f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
</code></pre>
<h4 id="4多重变量声明">4.多重变量声明</h4>
<p><code>var name1,name2,name3 type = val1,val2,val3</code></p>
<p><code>var name1,name2,name3 = val1,val2,val3</code></p>
<pre><code class="language-go">var (
	name1 type
	name2 type
) //这种因式分解关键子的变量声明一般用在声明全局变量
</code></pre>
<p>还可以使用:=对多个变量声明不同的类型</p>
<p><code>aa,bb,cc:=1,&quot;hello&quot;,true</code> 这称作并行声明</p>
<p><code>aa,bb,cc=1,&quot;hello&quot;,true</code>这称为并行赋值</p>
<p>并行赋值可用于接收多个函数返回值，类似于python</p>
<p>可用下划线来表示抛弃值，这种用法一方面可以用于保证声明的变量被使用，另一方面，有时函数的多个返回值我们并不需要每个值可以用这种方式来接收返回值。</p>
<p><code>_=aa</code>使用了aa这个变量，保证编译能过</p>
<p><code>_,need=func(a,b)</code>假设func有两个返回值，但不需要第一个返回值，可以这么写</p>
<p><strong>交换两个变量的值</strong>，在go中不需要借助辅助变量：</p>
<p><code>a,b=b,a</code>前提必须保证两个变量的类型相同</p>
<hr>
<h3 id="常量">常量</h3>
<p>http://books.studygolang.com/gopl-zh/ch3/ch3-06.html</p>
<p>Go语言的常量有个不同寻常之处。<strong>虽然一个常量可以有任意一个确定的基础类型</strong>，例如int或float64，或者是类似time.Duration这样命名的基础类型，<strong>但是许多常量并没有一个明确的基础类型</strong>。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>通过延迟明确常量的具体类型，<strong>无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</strong> 更像是字面值常量。。</p>
<pre><code class="language-go">var f float64 = 3 + 0i // untyped complex -&gt; float64
f = 2                  // untyped integer -&gt; float64
f = 1e123              // untyped floating-point -&gt; float64
f = 'a'                // untyped rune -&gt; float64
</code></pre>
<p><strong>如果对象的类型是确定的，则不会有隐式转换，必须显示转换。</strong></p>
<p>对于一个没有显式类型的变量声明（包括简短变量声明），<strong>常量的形式将隐式决定变量的默认类型</strong>，就像下面的例子：</p>
<pre><code class="language-Go">i := 0      // untyped integer;        implicit int(0)
r := '\000' // untyped rune;           implicit rune('\000')
f := 0.0    // untyped floating-point; implicit float64(0.0)
c := 0i     // untyped complex;        implicit complex128(0i)
</code></pre>
<p>当尝试将这些无类型的常量<strong>转为一个接口值</strong>时（例如将这些对象传给interface{}），这些<strong>默认类型将显得尤为重要</strong>，因为要靠它们明确接口对应的动态类型（用接口来判断承载的类型）。</p>
<p><strong>无类型整数常量转换为int，它的内存大小是不确定的</strong>，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：</p>
<pre><code class="language-Go">var i = int8(0)
var i int8 = 0
</code></pre>
<p>**不管是全局常量还是在函数中声明的常量，常量是在编译器创建的，而且只能是数字类型、字符、字符串或布尔类型。**因为编译时的限制，定义常量的表达式必须是常量表达式，这样编译器在编译时才能计算常量的值，而不能是一些例如函数计算值，因为调用函数是在代码运行阶段才执行的。</p>
<p>与变量声明相似，但不使用:=进行声明</p>
<pre><code class="language-go">const identifier [type] = value
</code></pre>
<p>一个未指定类型的常量（也即省略了[type]的声明），其类型由上下文决定：</p>
<pre><code class="language-go">const c1=100
func test1(a int) int{
	return a*10
}
func test2(a float32) float32{
	return a*1.2
}
func main(){
    fmt.Println(test1(c1))
    fmt.Println(test2(c1))
}
//output
1000
120.00001
</code></pre>
<p>常量也可用下列方式声明</p>
<pre><code class="language-go">const (
	a = 1
	b = 2
	c = 3
)
</code></pre>
<p>常量还可使用内置的函数进行计算，注意必须为内置函数，否则编译不过</p>
<pre><code class="language-go">const (
	a = &quot;hello&quot;
	b = len(a)
	c = unsafe.Sizeof(b)
)
</code></pre>
<p>在定义常量组时，如果<strong>不提供初始值</strong>，则后续的常量会使用上一行的值</p>
<pre><code class="language-go">const(
	a = 1
	b
	c
	d
)
//则a,b,c,d均为1
</code></pre>
<h4 id="iota-特殊常量">iota 特殊常量</h4>
<p>这是一个特殊的常量， 在 <strong>const关键字出现时将被重置为 0</strong>(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota <strong>计数一次</strong>(iota 可理解为 const 语句块中的行索引)。</p>
<pre><code class="language-go">const (
    a = iota
    b = iota
    c = iota
)// a=0 b=1 c=2
</code></pre>
<pre><code class="language-go">const (
    a = iota
    b
    c
) //a=0 b=1 c=2
</code></pre>
<p>搭配常量组不初始化时的特性，有</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = &quot;ha&quot;   //独立值，iota += 1
            e          //&quot;ha&quot;   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
} //输出结果 0 1 2 ha ha 100 100 7 8
</code></pre>
<pre><code class="language-go">//一个有趣的例子，k和l分别为数值3左移3和4位
const (
    i=1&lt;&lt;iota
    j=3&lt;&lt;iota
    k
    l
)// 输出结果 i= 1 j= 6 k= 12 l= 24

const(
	a = 5*iota
    b
    c
) //输出结果 a=0 b=5 c=10
</code></pre>
<p>这里其实是后续没有给初始化的常量保持了上一行的运算规则</p>
<p><strong>iota只在同一个常量组中计数自增；别的常量中的iota重置，重新计数。</strong></p>
<hr>
<h3 id="运算符">运算符</h3>
<p>各类符号、优先级与C++相同</p>
<p>要注意自增、自减只有后置，没有前置用法，且自增与赋值不能同时使用：</p>
<p><code>a=b++</code>这是错误的语法，编译不过</p>
<p><code>++</code> <code>--</code>都是声明，不是表达式，所以只能够单独a++或a--，不存在其与其他运算符搭配在一起形成表达式</p>
<p>Go语言中的逗号跟C++中的不一样，C++中的是一个表达式，例如1+2,3+4得到的是3（计算完两侧的表达式后，返回左表达式的值），而Go中的逗号就是一个分隔作用，没有表达式的含义。</p>
<pre><code>&amp;      位运算 AND
|      位运算 OR
^      位运算 XOR
&amp;^     位清空（AND NOT）
&lt;&lt;     左移
&gt;&gt;     右移
</code></pre>
<p>其中&amp;<sup>的含义是按位置零，例如x&amp;</sup>y，若y中某位为1，则x的相应位置为0后作为返回值。</p>
<hr>
<h4 id="命令行参数">命令行参数</h4>
<p>通过 程序名 arg1 arg2 arg3 来输入命令函参数的，Go语言提供了os包，命令函参数存在了os.Args切片中，这是一个string类型的切片，第一个元素为程序名，后面的则为参数的值。</p>
<pre><code class="language-go">import &quot;os&quot;
func main(){
	for i:=1;i&lt;len(os.Args);i++{
		fmt.Println(os.Args[i])
	}
}
go build hello.go
./hello nihao rex
nihao
rex
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言函数]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-han-shu/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-han-shu/">
        </link>
        <updated>2022-08-28T08:44:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go语言函数">Go语言函数</h3>
<p>go<strong>不支持函数重载</strong></p>
<p><strong>go的函数没有顺序要求</strong>，不像C++要先声明了函数后面的代码才能用，go中要调用的函数的声明在当前代码块的后面也可以执行。</p>
<p>函数写法：</p>
<pre><code class="language-go">func function_name( [parameter list] ) [return_types] {
   函数体
}
</code></pre>
<p>若函数不返回值，则可以不需要返回类型，类似于void</p>
<p>函数可以返回多个值，可以有多个返回类型：</p>
<pre><code class="language-go">func test(a,b int,c,d string) (int, string) {
	return 1, &quot;yes&quot;
}// 形参a，b为int，c，d为string，注意这里的类型判断逻辑
</code></pre>
<p>**值传递和C++一样，**其实go中存在的都是值传递，只不过如果传的是个指针或者地址，那么表现上就像引用传递一样，能够在函数内部修改外部传进来的变量</p>
<p><strong>引用传递，传的是变量的地址，因此在引用传递下的函数形参是指针类型。</strong></p>
<p>slice，map，channel 会有传引用的错觉(比如切片，他背后对应的是一个数组，切片本身是一个数据结构，在这个数据结构中包含了指向了这个数组的指针。所以说，即便是在传值的情况下这个结构被复制到函数里了，在通过指针去操作这个数组的值的时候，其实是操作的是同一块空间，实际上是结构被复制了，但是结构里包含的指针指向的是同一个数组，所以才有这个错觉)</p>
<p><strong>与C++不同，Go语言的函数返回值可以是局部对象的指针，这是一个很大的区别。：</strong></p>
<pre><code class="language-go">func ret_pointer() (*int){
	i:=123
	return &amp;i
}
func main(){
	ptr:=ret_pointer()
	fmt.Println(*ptr)
} //output 123
</code></pre>
<p>对于有多个返回值的函数，例如range一个数组，或者返回错误码和错误信息的函数等等，我们可以选择性的接收返回值的个数：<br>
只接收第一个返回值：</p>
<pre><code class="language-go">func test_func1() (int,string){ 
/* */ 
}
func main(){
	ret:=test_func1()
}
</code></pre>
<p>可以通过下划线忽略返回值列表中的某个返回值：</p>
<pre><code class="language-go">func test_func2() (int,string,float32){ 
/* */ 
}
func main(){
	ret_int,_,ret_float:=test_func1()
}
</code></pre>
<p>******</p>
<p><strong>函数返回值如果指定了名字</strong>，Go会在进入函数后，执行函数代码前，初始化这些命名了的返回值为其类型对应的零值，此时，如果函数的return没有跟任何东西，则Go会自动把return时的命名返回值返回给调用者：</p>
<pre><code class="language-go">func namedFunc() (n int, s string){
	n=123
	s=&quot;helloworld&quot;
	return 
}
func main(){
	i,s:=namedFunc()
	fmt.Println(i,s)
}//output 123 helloworld
</code></pre>
<p>所以这种使用命名了的返回值的情况下，要么return后不跟东西，Go自动帮你返回你指定名字的返回值，要么你return+命名的返回值，以上面的代码为例，namedFunc函数中的另一种返回方式为：<code>return n,s</code></p>
<p>******</p>
<hr>
<h3 id="闭包">闭包</h3>
<p>普通函数是静态的，而闭包是动态的，只有在运行时才知道这个闭包到底引用了什么变量，变量的值多少</p>
<p>函数闭包可以简单的理解成定义在一个函数体内的函数，闭包函数可以<strong>引用</strong>其<strong>外部</strong>函数的<strong>变量</strong>，每调用一次外部函数就生成一个单独的闭包，互不影响</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165512260-1.png" alt="image" loading="lazy"></figure>
<p>通过调用外部的函数，得到一个闭包函数，这个闭包函数引用了这个外部函数的对象的一份副本，每个闭包函数各自独立，各自是一个包一样。</p>
<pre><code class="language-go">func test2() func() int {
	i := 1
	return func() int {
		i++
		return i
	}
}
func main(){
	clp1 := test2()
	fmt.Println(clp1())
	fmt.Println(clp1())
	clp2 := test2()
	fmt.Println(clp2())
	fmt.Println(clp2())
}//输出
2 
3
2 
3
</code></pre>
<p>不一定说必须在函数内部定义的函数才可能是闭包（其实就是外部变量对于内部函数而言是可见的，所以可以引用）：</p>
<pre><code class="language-go">func main() {

	for i:=0; i&lt;5; i++ {
		go func(){
			fmt.Println(i) 
		//i变量值也是引用.创建5个线程执行函数，线程刚好处于i的某个值，输出的值不确定
		}()
		
	}
	time.Sleep(time.Second * 1)
}
</code></pre>
<hr>
<h3 id="函数方法">函数方法</h3>
<p>Go语言没有面向对象。</p>
<p><strong>可以给所有的自定义名字的类型添加方法，除了接口和指针类型外。</strong></p>
<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>
<p><strong>规则</strong>：以值类型作为接收者的方法既可以通过对象的值也可以通过对象的指针触发，但指针类型作为接收者的时候，就只能通过对象的指针触发。这是因为值接收者在方法里其实操作的是对象的副本，不管是类型的指针还是值，都没影响；而指针接收者要修改对象的值，所以存在一定的区别。</p>
<p>但是如果值对象可以取址，那么通过它调用指针接收者的方法也是可以的，否则一定要按照这个规则来：</p>
<pre><code class="language-go">type newStruct struct {
	a, b int
}
func (ns *newStruct) test_pointer() {
	fmt.Println(&quot;invoked by pointer receiver method&quot;)
}
func (ns newStruct) test_no_pointer() {
	fmt.Println(&quot;invoked by no pointer receiver method&quot;)
}
func main(){
	ns:=newStruct{123,456}  //类型的值
	ns.test_no_pointer() //调用值接收者的方法，当然没问题
    ns.test_pointer()    //调用指针接受者的方法，只要对象可以取址，编译器会自动补上&amp;后再调用，也即编译器优化后实际执行的是(&amp;ns).test_pointer()
	
	nns:=new(newStruct) //类型的指针
	nns.test_no_pointer() //调用值接收者的方法，值接收者的方法可以使用类型的指针进行调用
	nns.test_pointer()   //调用指针接收者的方法，当然没问题
	
}

</code></pre>
<p>函数方法就是通过编写一个函数，与某一类型相关联，然后在后续的函数调用上，如同该类型的成员方法一样：</p>
<pre><code class="language-go">func (variable_name variable_data_type) function_name() [return_type]{
   /* 函数体*/
}

</code></pre>
<pre><code class="language-go">//example
type mystruct struct{
	radius float32
}
func (c mystruct) getRadius() float32{
	return c.radius
}
func main(){
	var Test mystruct
	Test.radius=123.456
	fmt.Println(Test.getRadius)//如同mystruct类型的成员方法一样
}//输出 123.456

</code></pre>
<p>如果想要修改类型的值，用该类型的指针来编写：</p>
<pre><code class="language-go">//example
type mystruct struct{
	radius float32
}
func (c *mystruct) setRadius(newRadius float32){
	c.radius=newRadius //注意这里，虽然是指针但是还是用了句号运算符
    //在C++中指针访问成员是用箭头运算符，但这里不一样，多加注意
}
func main(){
	var Test mystruct
	Test.radius=123.456
    Test.setRadius(555.666)
	fmt.Println(Test.radius)//如同mystruct类型的成员方法一样
}//输出 555.666

</code></pre>
<p>如果不是使用指针的方法来编写类型的方法，一方面是无法实现修改对象的效果，另一方面是每次都是值传递，操作的都是这个对象的副本，会存在开辟新的内存的情况，个人认为，即使方法不修改对象的值，也最好用指针的方式，减少内存的创建和销毁：</p>
<pre><code class="language-go">type MyStruct struct {
	radius float32
	height float32
}

func (m *MyStruct) ModifyP() {
	m.radius = 10
	m.height = 20
}

func (m MyStruct) Modify() {
	m.radius = 10
	m.height = 20
}

func PrintMystruct(m *MyStruct) {
	fmt.Println(&quot;radius: &quot;, m.radius)
	fmt.Println(&quot;height: &quot;, m.height)
}

func main() {
	ms := MyStruct{1.2, 2.4}
	PrintMystruct(&amp;ms)
	ms.Modify()
	PrintMystruct(&amp;ms)
	ms.ModifyP()
	PrintMystruct(&amp;ms)
}
//output
radius:  1.2
height:  2.4
radius:  1.2
height:  2.4
radius:  10
height:  20

</code></pre>
<p>对于采用值和指针作为接收者的两种编写方法的方式，最完整的调用方法的方式如下，但指针接收者也可像值接收者那样，不需要取址后再调用方法，我们编写m.test2()，go编译器会自动解释为(&amp;m).test2()。</p>
<pre><code class="language-go">func (m Mystruct) test1(){
	/* code */
}
func (m *Mystruct) test2(){
	/* code */
}
func main(){
	m:=Mystruct()
	m.test1()
	(&amp;m).test2() //指针接收者的最完整调用方法的方式，也可以像上面那行那样调用，也是没问题的
}

</code></pre>
<p>不能给基本变量类型（内置类型）添加函数方法**，只能给自定义的类型添加函数方法。但是可以使用类似typedef一样的效果，给内置变量取别名，然后再对该别名声明方法：</p>
<pre><code class="language-go">type MyInt int
func(i MyInt) test() Myint{ //要注意虽然MyInt本质上就是int，但是两种类型的变量不能赋值，所以这里不能用int做返回类型
	return i*i
}
func main(){
    i:=MyInt(2)
    fmt.Println(i.test())
}//output 4

</code></pre>
<p><strong>只能给同一个包里的定义的类型编写方法</strong>，不能给其他包内的类型写方法，所以这也是为什么不能给内置类型添加方法的原因，因为内置变量的定义在其他包内。</p>
<hr>
<h3 id="变量作用域">变量作用域</h3>
<p><strong>作用域基本规则与C++一样</strong>，可以用大括号来划分作用域。</p>
<ul>
<li>
<p>函数内定义的变量称为局部变量</p>
</li>
<li>
<p>函数外定义的变量称为全局变量</p>
</li>
<li>
<p>函数定义中的变量称为形式参数</p>
<p>局部变量和全局变量<strong>默认初始化为零值</strong>。</p>
</li>
</ul>
<h4 id="局部变量">局部变量</h4>
<p>函数内的变量、形参、返回值都是局部变量</p>
<h4 id="全局变量">全局变量</h4>
<p>函数体外声明的变量为全局变量。一个包里的对象想要别的包可见的话，需要首字母大写；而如果是同一个包的不同文件，则直接使用对象即可，不区分首字母大小写的问题，但是在运行时需要告诉编译器是包的哪几个文件：</p>
<p>hello.go引用了test.go的函数和变量，运行代码应为:go run test.go hello.go （两个文件谁前谁后无所谓）</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165552187-1.png" alt="image" loading="lazy"></figure>
<p>全局变量可以与局部变量同名，但内部的局部变量会屏蔽外部的同名变量</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言的一些内置函数]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-de-yi-xie-nei-zhi-han-shu/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-de-yi-xie-nei-zhi-han-shu/">
        </link>
        <updated>2022-08-28T08:43:51.000Z</updated>
        <content type="html"><![CDATA[<h4 id="new">new</h4>
<p><code>new(type)</code>返回的是类型type对象的指针</p>
<p>和直接通过var声明变量一样，new会根据不同的类型，赋予相应的零值（未初始化）</p>
<p>例如new([]int)得到的是一个<strong>nil</strong>切片的头指针</p>
<h4 id="make">make</h4>
<p>make函数只能用于创建切片、map和通道channel变量，并且会对这些变量进行初始化，不再是零值，可以直接进行使用，例如make 生成的切片可以直接赋值使用。</p>
<p>make返回的是变量而不是指针，由于make的变量都是些数据结构，所以必须要初始化，保证后续代码对这些变量的正确使用。</p>
<p>new和make的区别</p>
<pre><code class="language-go">var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints
</code></pre>
<h4 id="打印函数">打印函数</h4>
<p>Go的标准库fmt中包含了许多用于打印的函数</p>
<p>例如Print,Println,Sprintf,Fprintf等等，<strong>其中Sprintf返回的是一个字符串</strong>，而不是像C++那样将格式化后的字符串写入缓冲区中。</p>
<p>下面的几种打印方式，结果是一样的。</p>
<pre><code class="language-go">fmt.Printf(&quot;Hello %d\n&quot;, 23)
fmt.Fprint(os.Stdout, &quot;Hello &quot;, 23, &quot;\n&quot;)
fmt.Println(&quot;Hello&quot;, 23)
fmt.Println(fmt.Sprint(&quot;Hello &quot;, 23))
</code></pre>
<p>注意到Fprintf的第一个参数是一个实现了io.Writer接口的类型。</p>
<p>格式化字符：</p>
<table>
<thead>
<tr>
<th style="text-align:right">**格式   **</th>
<th style="text-align:center"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">%%</td>
<td style="text-align:center">一个%字面量</td>
</tr>
<tr>
<td style="text-align:right">%b</td>
<td style="text-align:center">一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数</td>
</tr>
<tr>
<td style="text-align:right">%c</td>
<td style="text-align:center">字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td>
</tr>
<tr>
<td style="text-align:right">%d</td>
<td style="text-align:center">一个十进制数值(基数为10)</td>
</tr>
<tr>
<td style="text-align:right">%e</td>
<td style="text-align:center">以科学记数法e表示的浮点数或者复数值</td>
</tr>
<tr>
<td style="text-align:right">%E</td>
<td style="text-align:center">以科学记数法E表示的浮点数或者复数值</td>
</tr>
<tr>
<td style="text-align:right">%f</td>
<td style="text-align:center">以标准记数法表示的浮点数或者复数值</td>
</tr>
<tr>
<td style="text-align:right">%g</td>
<td style="text-align:center">以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td>
</tr>
<tr>
<td style="text-align:right">%G</td>
<td style="text-align:center">以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出</td>
</tr>
<tr>
<td style="text-align:right">%o</td>
<td style="text-align:center">一个以八进制表示的数字(基数为8)</td>
</tr>
<tr>
<td style="text-align:right">%p</td>
<td style="text-align:center">以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示</td>
</tr>
<tr>
<td style="text-align:right">%q</td>
<td style="text-align:center">使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字</td>
</tr>
<tr>
<td style="text-align:right">%s</td>
<td style="text-align:center">字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\0‘结尾，这个'\0'即空字符）</td>
</tr>
<tr>
<td style="text-align:right">%t</td>
<td style="text-align:center">以true或者false输出的布尔值</td>
</tr>
<tr>
<td style="text-align:right"><strong>%T</strong></td>
<td style="text-align:center">使用Go语法输出的值的类型</td>
</tr>
<tr>
<td style="text-align:right">%U</td>
<td style="text-align:center">一个用Unicode表示法表示的整型码点，默认值为4个数字字符</td>
</tr>
<tr>
<td style="text-align:right"><strong>%v</strong></td>
<td style="text-align:center">使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话</td>
</tr>
<tr>
<td style="text-align:right">%x</td>
<td style="text-align:center">以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示</td>
</tr>
<tr>
<td style="text-align:right">%X</td>
<td style="text-align:center">以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示</td>
</tr>
</tbody>
</table>
<pre><code class="language-Go">o := 0666
fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot;
x := int64(0xdeadbeef)
fmt.Printf(&quot;%d %[1]x %#[1]x %#[1]X\n&quot;, x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
</code></pre>
<p>请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数<strong>再次使用第一个操作数</strong>。第二，%后的<code>#</code>副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。</p>
<p>当打印一个结构体时，使用%+v同时打印结构体的字段名和该字段对应的值，使用%#v则能够打印出Go中完整的符号：</p>
<pre><code class="language-go">m2:= map[int]string{2:&quot;world&quot;}
fmt.Printf(&quot;%+v\n&quot;, m2)
fmt.Printf(&quot;%#v\n&quot;, m2)
//output
map[2:world]
map[int]string{2:&quot;world&quot;}
</code></pre>
<p>如果想通过%v按照自己想要的输出内容打印自己定义的类型，可以为自己的类型添加String() string 方法，fmt包打印时会调用这个函数。</p>
<pre><code class="language-go">type newStruct struct {
	a, b int
}

func (ns *newStruct) String() string {
	return fmt.Sprintf(&quot;In newStruct a is %d b is %d&quot;, ns.a, ns.b)
}

func main(){
	ns := new(newStruct)
	ns.a = 123
	ns.b = 456
	fmt.Printf(&quot;%v\n&quot;, ns)
}
//output
In newStruct a is 123 b is 456
</code></pre>
<p>如果说想通过%v既可以自定义打印对象指针，也可以打印对象，<strong>那么String方法的接收者必须为该类型的值类型，而不是指针类型：</strong></p>
<pre><code class="language-go">type newStruct struct {
	a, b int
}

func (ns newStruct) String() string {
	return fmt.Sprintf(&quot;In newStruct a is %d b is %d&quot;, ns.a, ns.b)
}
func main(){
	ns := new(newStruct)
	ns.a = 123
	ns.b = 456
	nns := newStruct{a: 777, b: 888}
	fmt.Printf(&quot;%v\n&quot;, ns)
	fmt.Printf(&quot;%v\n&quot;, nns)
}
//output
In newStruct a is 123 b is 456
In newStruct a is 777 b is 888
</code></pre>
<p>Sprintf函数<strong>以%s字符串的形式</strong>打印一个类型对象时，也会去调用该类型的实现的String方法，因为它想要一个字符串结果，所以，<strong>要注意不能在实现类型A的String函数的内部调用Sprintf去打印A，因为会一直递归调用String</strong>。如果真要在String函数内部打印类型A对象本身，一个简单的方法就是强制转换成没有实现String函数的类型，例如基本的string类型就没有实现该方法：</p>
<pre><code class="language-go">type MyString string
func (m MyString) String() string {
    return fmt.Sprintf(&quot;MyString=%s&quot;, string(m)) // OK: note conversion.
}
</code></pre>
<p>fmt包的打印函数都可以接收多个参数，打印多个变量的内容，因为空接口类型可以接收任何类型的对象，所以这些函数原型大致如下：</p>
<pre><code class="language-go">func Printf(format string, v ...interface{})
</code></pre>
<p>Within the function <code>Printf</code>, <code>v</code> acts like a variable of type <code>[]interface{}</code> but if it is passed to another variadic function, it acts like a regular list of arguments.</p>
<p>其中...代表这个变量其实是一个包，作为参数时可以理解成v是一个包，而在函数内部使用时，可以看成是一个列表：</p>
<pre><code class="language-go">// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}

</code></pre>
<p>在这个参数的函数内部，这个变量如同一个切片一样，而如果把他传给另外一个支持可变参数的函数，那么这个就可以看成是一个参数列表，所以上面的Sprintln中的v后缀必须要加...，不然传给这个函数的v是一个值，而不是一个列表（包）。</p>
<p>其实对于这种...的参数，可以看成是一个切片：</p>
<pre><code class="language-go">func listParams(a ...int) {
	for _, val := range a {
		fmt.Println(val)
	}

}
func main(){
	listParams(1,2,3)
}
//output
1
2
3

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言错误处理]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-cuo-wu-chu-li/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-cuo-wu-chu-li/">
        </link>
        <updated>2022-08-28T08:43:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go语言的错误处理">Go语言的错误处理</h3>
<p>首先区分错误和异常，错误是正常的业务逻辑，例如错误码，错误信息等，可以代码中处理好，进行日志记录；而异常则更为致命，例如段错误，访问野指针等，一般会造成程序的崩溃。</p>
<p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。 其定义如下：</p>
<pre><code class="language-go">type error interface{
	Error() string
}
</code></pre>
<p>自定义的类型可以实现这个方法，来得到相应的错误处理函数</p>
<p>以打开文件失败返回错误为例：</p>
<pre><code class="language-go">import( &quot;fmt&quot; &quot;os&quot; )
func main(){
	file,err:=os.Open(&quot;test.txt&quot;)
	if err!=nil{
		fmt.Println(err.Error()) //output no such file or directory
	}
}
</code></pre>
<p>os.Open函数返回的err其实是实现了接口error的os.Patherror的指针，是一个error接口类型，所以可以进行断言：</p>
<pre><code class="language-go">import( &quot;fmt&quot; &quot;os&quot; )
func main(){
	file,err:=os.Open(&quot;test.txt&quot;)
    if val,ok:=err.(*os.Patherror){
		fmt.Println(val.Error()) //output no such file or directory
	}
}
</code></pre>
<p>因此，这提供了一种处理错误的思路，我们可以自定义一个结构体，这个结构体的字段是我们在遇到错误时需要的信息字段，例如errmsg、errcode，然后对这个结构体实现接口error，在编写函数返回值时，返回类型指定为error类型，返回该结构体的指针（如果不是指针，变成值传递，临时变量会销毁），然后进行类型断言，确保是某类错误后，再去获取错误信息。返回的error对象应该是最好是最后一个变量（规范化）。</p>
<pre><code class="language-go">type s1 struct {
	radius float32
}
func (s s1) Error() string {
	return &quot;error from s1&quot;
}

func test_error() (int, error) {
	return -1, new(s1)
}

func main(){
	_, myerr := test_error()
	if val, ok := myerr.(*s1); ok {
		fmt.Println(val.Error())
	}
}//output error from s1
</code></pre>
<hr>
<h3 id="go语言异常处理">Go语言异常处理</h3>
<p>在程序编写时，尽量使用错误而不是异常处理，因为异常往往是程序要崩溃了。</p>
<p>常见的异常为访问野指针导致段错误，或者程序指定要绑定某个端口，但反复重试后仍无法绑定，则抛出异常。</p>
<p>go中抛出异常使用的函数为<strong>panic</strong>函数，这个函数的作用很像C++中的throw，<strong>运行时程序崩溃其实也是调用了panic函数</strong>。panic是会不断往外层函数传递的，直到有函数处理了它，或者没有函数处理进而程序退出。</p>
<pre><code class="language-go">func panic(v interface{})
</code></pre>
<p>当调用panic函数后程序终止了，会打印传入给panic的参数，同时还会打印函数调用栈，类同backtrace，返回堆栈信息</p>
<pre><code class="language-go">func main(){
	panic(&quot;exit at start&quot;)
}

//output
panic: exit at start

goroutine 1 [running]:
main.main()
        /root/learn_go/var.go:80 +0x39
exit status 2
</code></pre>
<h4 id="延迟函数延迟语句-关键字defer">延迟函数/延迟语句 关键字：defer</h4>
<p><strong>在异常情况下（调用panic函数或程序崩溃时）</strong>：使用defer关键字，后面跟的语句、函数会在panic函数调用后/程序退出前执行，类似于apue中的atexit函数，执行的顺序和defer语句的执行顺序相反（栈结构）</p>
<p>defer语句虽然是在其所在函数返回后再进行执行，但如果defer语句中的表达式求值在程序运行到该语句时就执行了求值，例如defer函数的参数在此时已经确定了，即使后面更改了传入的参数的值，也没有影响：</p>
<pre><code class="language-go">func df(a, b int) int {
	return a + b
}
func main(){
	a := 10
	b := 20
	defer fmt.Println(df(a, b))
	a += b
	fmt.Println(a + b)
}//output
50 //main中最后一行打印的结果
30 //defer函数的执行结果
</code></pre>
<pre><code class="language-go">func test_defer(){
	defer fmt.Println(&quot;defer in test_defer&quot;)
	panic(&quot;panic in test_defer&quot;)
}
func main(){
	defer fmt.Println(&quot;defer in main&quot;)
}
//output
defer in test_defer
defer in main
panic: panic in test_defer

goroutine 1 [running]:
main.test_defer()
        /root/learn_go/var.go:81 +0x95
main.main()
        /root/learn_go/var.go:86 +0xb1
exit status 2
</code></pre>
<p>可以看到，每个defer都会把语句压入栈中，等到<strong>程序退出前</strong>（正常退出或者panic退出）再从栈顶逐一执行，先压入了main的defer，后压入了test_defer函数中的defer语句。</p>
<p><strong>在执行完所有的defer语句后，再执行panic函数。</strong></p>
<p><strong>正常情况下</strong>：在某个函数中使用了defer语句，则在该函数return前，会执行所有在该函数中注册的每个defer语句，然后再return。只要函数不return或者异常结束，该函数内声明的defer语句都不会执行。</p>
<pre><code class="language-go">func test_defer() string {
	defer fmt.Println(&quot;defer in test_defer&quot;)
    defer fmt.Println(&quot;defer in test_defer 2&quot;)
	return &quot;hello&quot;

}
func main() {
	defer fmt.Println(&quot;defer in main&quot;)
	fmt.Println(test_defer())
}
//output
defer in test_defer 2
defer in test_defer
hello
defer in main

</code></pre>
<p><strong>在正常情况下</strong>，defer语句的执行顺序是：<strong>先return，后再执行defer语句</strong>。</p>
<pre><code class="language-go">func test_defer() int {
	i := 0
	defer func() {
		i++
		fmt.Println(&quot;first state defer&quot;, i)
	}()
	defer func() {
		i++
		fmt.Println(&quot;second state defer&quot;, i)
	}()
	return i
}
func main(){
	fmt.Println(test_defer())
}
//output
second state defer 1
first state defer 2
0

</code></pre>
<h4 id="recover函数">recover函数</h4>
<p>程序在panic之后，调用recover可以恢复程序，不让程序崩溃退出，有点像C++的catch异常的感觉。只要处理了异常，就不会使得程序退出。</p>
<p>A call to <code>recover</code> stops the unwinding and returns the argument passed to <code>panic</code>.</p>
<p><strong>recover函数返回值是传给panic函数的参数</strong>，返回类型就是interface{}，这个类型就是panic函数形参类型。</p>
<p>只能够在延迟函数中调用recover函数来恢复程序，直接调用是不行的：</p>
<pre><code class="language-go">func test_defer(){
	defer func(){
		recover()
		fmt.Println(&quot;recovered&quot;)
	}()
	panic(&quot;panic in test_defer&quot;)
}
func main(){
	test_defer()
	fmt.Println(&quot;in main&quot;)
}
//output
recovered
in main

</code></pre>
<p>在与recover搭配的情况下，<strong>panic其实是提前中断了其所在的函数</strong>（panic代码所在行后所有的语句是不会执行的），其会在所在的函数体内，找defer函数中是否有调用recover，<strong>没有的话就返回上一层函数，继续寻找</strong>，如果都没找到，则程序结束，否则程序恢复正常运行，不会退出：</p>
<pre><code class="language-go">func test(){
	panic(&quot;panic in test&quot;)
}
func main(){
	defer func(){
		recover()
		fmt.Println(&quot;recovered&quot;)
	}()
	fmt.Println(&quot;normal output&quot;)
}
//output 
recovered

</code></pre>
<p>可以看到上述代码中，即使recover从panic中恢复了，但仍然没有输出normal output，这是因为test函数中没有recover，panic传到了外层main函数，main函数提前终止，然后才调用了defer语句，才有了接下来的输出。</p>
<p>除了自己调用panic，运行时也会出现panic，例如未知的情况下访问了野指针，也可以通过recover来恢复，不过这需要在可能出现panic的函数体的第一句就写好延迟函数：</p>
<pre><code class="language-go">func may_panic(){
	defer func(){
		recover()
	}
	/* code */
}

</code></pre>
<p>A call to <code>recover</code> stops the unwinding and returns the argument passed to <code>panic</code>. Because the only code that runs while unwinding is inside deferred functions, <code>recover</code> is only useful inside deferred functions.</p>
<p>下面的例子可用于理解为什么defer函数是在return之后执行的</p>
<pre><code class="language-go">// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}

</code></pre>
<p>上面这个例子可能存在一个re-panic现象，也即如果e.(Error)这个类型判断失败，会再一次引起panic，这就是所谓的在处理异常的过程中又发生了异常，这时候就会再往上找recover函数，同时，<strong>re-panic的每一次panic信息都会打印。</strong></p>
<p>defer函数在return之后调用的原因：上面这个函数在return的地方调用了函数，而这个函数可能出现panic，此时defer函数才可以发挥作用，执行recover；否则这个panic就没办法在Compile函数内部被捕捉。</p>
<p>此外，<strong>defer函数可以修改命名的返回值</strong>，可以看到defer函数内部，在panic后，将regexp赋值为nil。</p>
<p>实践例子：</p>
<pre><code class="language-go">func derfer_test() (s string) {
	defer func() {
		s = &quot;changed in defer&quot;
	}()
	return &quot;Not change&quot;
}
func main(){
	fmt.Println(defer_test())
}
//output
changed in defer

</code></pre>
<p>使用panic和recover的建议，这一套应该在package中处理，不应该暴露给用户，应是package出现了panic后，使用recover返回一个error给用户，避免暴露panic信息给用户。</p>
<p>Useful though this pattern is, it should be used only within a package. <code>Parse</code> turns its internal <code>panic</code> calls into <code>error</code> values; it does not expose <code>panics</code> to its client. That is a good rule to follow.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go语言并发]]></title>
        <id>https://rexxxzhou.github.io/post/go-yu-yan-bing-fa/</id>
        <link href="https://rexxxzhou.github.io/post/go-yu-yan-bing-fa/">
        </link>
        <updated>2022-08-28T08:43:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="go语言并发">Go语言并发</h3>
<p>在go语言中，程序是以goroutine的形式执行的，每个goroutine就是一个轻量级用户线程，可以使用关键字go来说生成一个新的线程去执行函数，类似于创建thread时指定它要执行的函数：</p>
<pre><code class="language-go">func test_go() {
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	time.Sleep(time.Second)
}
//output
helloworld
</code></pre>
<h4 id="gpm模型">GPM模型</h4>
<p>每个 P 都有一个队列，用来存正在执行的 G。避免 Global Sched Lock。</p>
<p>每个 M 运行都需要一个 MCache 结构。M Pool 中通常有较多 M，但执行的只有几个，为每个池子中的每个 M 分配一个 MCache 则会形成不必要的浪费，通过把 cache 从 M 移到 P，每个运行的 M 都有关联的 P，这样只有运行的 M 才有自己的 MCache。</p>
<p>Goroutine的增长是在堆上分配空间的。</p>
<p>https://zhuanlan.zhihu.com/p/323271088</p>
<p>https://www.zhihu.com/question/20862617</p>
<p>教程：https://www.bilibili.com/video/BV19r4y1w7Nx</p>
<p>G(goroutine),P(processor),M(工作线程)，三者要互相绑定，才能正常运行。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165745367-1.png" alt="image" loading="lazy"></figure>
<h4 id="信道-chan">信道 chan</h4>
<p><strong>信道是一个先进先出的数据结构，可以看作一个线程安全的队列。</strong></p>
<p>go语言中，每个goroutine可以通过channel变量进行通信，来感知别的线程的工作情况。</p>
<p>channel变量在不指定缓冲区大小的情况下是无缓冲的</p>
<p><code>make(chan int , 2) </code>返回的是一个缓冲区大小为2的信道，这个<strong>返回值作用像是一个指向底层数据结构的引用</strong>。所以在函数间进行作为参数进行传递就跟传引用一样，都引用/使用这个底层信道数据对象。</p>
<pre><code class="language-go">c:=make(chan int) //创建一个信道内传递整数的无缓冲信道

//在函数外声明chan变量
var c chan int=make(chan int)
</code></pre>
<p>对于无缓冲的信道，对信道的读和写都是阻塞的。无缓冲的信道不做数据的存储，只体现为数据的流通。</p>
<p>1.对于写而言，如果没有goroutine从信道读取，则写的goroutine会被阻塞挂起</p>
<p>​	写的语法：<code>channel&lt;-5</code></p>
<p>2.对于读而言，如果没有goroutine对信道写入，则读的goroutine会被阻塞挂起</p>
<p>​	读的语法：<code>&lt;-channel</code></p>
<pre><code class="language-go">var channel chan int = make(chan int) //必须要make赋值，否则是个nil的chan，行为会异常

func test_go() {
	channel &lt;- 5
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	&lt;-channel
	time.Sleep(time.Second)
}
//output helloworld
</code></pre>
<p>因此，<strong>对于无缓冲的信道，读写必须是成套的</strong>，在没有成套之前，goroutine会被挂起，所以这里也很容易出现死锁问题。</p>
<p>go语言在运行时能感知到信道的死锁，若出现死锁，运行时报错：</p>
<pre><code>fatal error: all goroutines are asleep - deadlock!
</code></pre>
<p>缓冲信道，在使用make创建信道时，可以指定信道的大小，也即缓冲区的大小。这时的信道有点像容器一样，可以装最多缓冲区大小的元素。</p>
<pre><code class="language-go">c2:=make(chan int,2) //创建一个信道内传递整数的缓冲去大小为2的信道

//在函数外声明chan变量
var c2 chan int=make(chan int,2)
</code></pre>
<p>若信道缓冲区已满，后续对信道的写入将会阻塞，goroutine会被挂起；同理，如果信道缓冲区为空，则读取操作讲阻塞挂起。带缓冲的信道就和TCP连接的独写处理方式相似了。</p>
<p><strong>控制信道的读写权限</strong>：</p>
<pre><code class="language-go">var c1 chan int //可读可写
var c2 &lt;-chan int //只读
var c3 chan&lt;- int //只写
</code></pre>
<h5 id="信道的读取和关闭">信道的读取和关闭</h5>
<p>带缓冲的信道如果某一时刻有很多个值在里面，逐一使用&lt;-channel的方式来读取代码上重复累赘，使用range可以遍历信道的元素（<strong>遍历操作就是读取</strong>），但如果信道是没有关闭的（即还能往信道里写入值），那么range的遍历是不会终止的，它会一直等下一个元素的到来，此时也会产生死锁。</p>
<pre><code class="language-go">var channel chan string = make(chan string, 1)

func test_go() {
	channel &lt;- &quot;hello&quot;
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	for ele := range channel {
		fmt.Println(ele)
	}
	time.Sleep(time.Second)
}
//output
helloworld
hello
fatal error: all goroutines are asleep - deadlock!
</code></pre>
<p>要么就是在for循环内添加if判断，判断信道当前大小<code>len(channel)</code>是否为0，是的话则break，但这种方法一定要保证没有其他的goroutine同时往信道写入，否则用于不会break。</p>
<p>另外一种方式就是关闭信道，<code>close(channel)</code>，关闭信道只是关闭了写入了，仍可正常读取，和TCP的close有点相像。</p>
<pre><code class="language-go">var channel chan string = make(chan string, 1)

func test_go() {
	channel &lt;- &quot;hello&quot;
	close(channel)
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	time.Sleep(time.Second)
	for ele := range channel {
		fmt.Println(ele)
	}
}
//output
helloworld
hello
</code></pre>
<p>或者通过<code>val,ok:=&lt;-channel</code>的方式来遍历也可以，<strong>如果信道关闭了则ok为false，停止循环</strong>：</p>
<pre><code class="language-go">	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}

</code></pre>
<p><strong>向一个关闭了信道继续写数据会引起程序panic</strong></p>
<h5 id="信道作为函数参数传递">信道作为函数参数传递</h5>
<p>不论是值传递还是传指针，<strong>效果跟传引用一样</strong>，修改了传入的信道：</p>
<pre><code class="language-go">//example 1
func test_trans(c *chan string) {
	*c &lt;- &quot;world&quot;
	close(*c)
}
func main() {
	test_trans(&amp;channel)
	time.Sleep(time.Second)
	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}
	fmt.Println(len(channel))
} //output world 0

//example 2
func test_trans(c chan string) {
	c &lt;- &quot;world&quot;
	close(c)
}
func main() {
	test_trans(channel)
	time.Sleep(time.Second)
	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}
	fmt.Println(len(channel))
} //output world 0

</code></pre>
<p>channel底层的数据结构，<strong>多个goroutine同时访问一个channel是协程安全的</strong>，因为底层数据结构有一个mutex互斥量，以保证每次从channel的写入和取出操作都是互斥的，原子性的，所以可以放心使用，效率和共享的队列应该差不多，毕竟都是用mutex来控制。</p>
<pre><code class="language-go">type hchan struct {
    // 通道里元素的数量
    qcount   uint
	// 循环队列的长度
    dataqsiz uint
	// 指针，指向存储缓冲通道数据的循环队列
    buf      unsafe.Pointer
	// 通道中元素的大小
    elemsize uint16
	// 通道是否关闭的标志
    closed   uint32
	// 通道中元素的类型
    elemtype *_type
	// 已接收元素在循环队列的索引
    sendx    uint  
	// 已发送元素在循环队列的索引
    recvx    uint
	// 等待接收的协程队列
    recvq    waitq
	// 等待发送的协程队列
    sendq    waitq
	// 互斥锁，保护hchan的并发读写，下文会讲
    lock mutex
}

</code></pre>
<p>————————————————<br>
原文链接：https://blog.csdn.net/jiangjiang04/article/details/105481940/</p>
<h3 id="syncmutex">sync.Mutex</h3>
<p>虽然使用chan变量可以实现不同goroutine之间的通信和同步，但有时候我们并不需要goroutine之间通信，而需要他们在访问同一共享对象时互斥，这时候就可以使用Go标准库提供的sync.Mutex互斥锁，原理上和C++的mutex是一样的，同一时刻只有一个goroutine获得了锁标记。<strong>Mutex在Go标准库sync包中</strong>。</p>
<pre><code class="language-go">import &quot;sync&quot;
type HasLock struct{
	mutex sync.Mutex
}
var global int = 20
func test_mutex(hl *HasLock){
	hl.mutex.Lock()
	fmt.Println(global++)
	hl.mutex.UnLock()
}
func main(){
	local_mutex:=HasLock{}
	for i:=0;i&lt;10;i++{
		go test_mutex(&amp;local_mutex)
	}
	time.Sleep(time.Second*5)
}
//output
21
22
23
24
25
26
27
28
29
30

</code></pre>
<hr>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func() {
            process(req) // Buggy; see explanation below.
            &lt;-sem
        }()
    }
}

</code></pre>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func(req *Request) {
            process(req)
            &lt;-sem
        }(req)
    }
}

</code></pre>
<p>注意上述两块代码，第一块代码中存在bug，原因是每个goroutine都复用了for循环中的局部变量req，共享了req（官网是这样解释的， 但是个人觉得好像没影响，感觉每次循环的req的值都不一样，应该不存在共享变量的问题）；第二块代码则是通过闭包的方式，每个goroutine都有自己req的副本，不存在共享问题，也可像下面这样：</p>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem &lt;- 1
        go func() {
            process(req)
            &lt;-sem
        }()
    }
}

</code></pre>
<p>注意比较奇怪的语法：在循环体内部用了req:=req，虽然看起来奇怪，但是go语言支持。</p>
<p>You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine.</p>
<hr>
<p>获取电脑的CPU核数：<code>runtime.NumCPU()</code></p>
<p>获取配置文件中的GOMAXPROCS参数：<code>runtime.GOMAXPROCS(0)</code></p>
<p>can</p>
]]></content>
    </entry>
</feed>