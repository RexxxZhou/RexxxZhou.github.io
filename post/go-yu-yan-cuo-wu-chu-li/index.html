<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Go语言错误处理 | Rexxxx&#39;s Blog</title>
<meta name="description" content="Life is a fucking movie, enjoy.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://rexxxzhou.github.io/favicon.ico?v=1678621911113">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://rexxxzhou.github.io/styles/main.css">


<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://rexxxzhou.github.io">Rexxxx&#39;s Blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Go语言错误处理</h1>
            <p class="article-meta">
              2022-08-28
              
                <a href="https://rexxxzhou.github.io/tag/bzcKfnF8X/" class="badge secondary">
                  Golang
                </a>
              
            </p>
            
            <div class="post-content" v-pre>
              <h3 id="go语言的错误处理">Go语言的错误处理</h3>
<p>首先区分错误和异常，错误是正常的业务逻辑，例如错误码，错误信息等，可以代码中处理好，进行日志记录；而异常则更为致命，例如段错误，访问野指针等，一般会造成程序的崩溃。</p>
<p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。 其定义如下：</p>
<pre><code class="language-go">type error interface{
	Error() string
}
</code></pre>
<p>自定义的类型可以实现这个方法，来得到相应的错误处理函数</p>
<p>以打开文件失败返回错误为例：</p>
<pre><code class="language-go">import( &quot;fmt&quot; &quot;os&quot; )
func main(){
	file,err:=os.Open(&quot;test.txt&quot;)
	if err!=nil{
		fmt.Println(err.Error()) //output no such file or directory
	}
}
</code></pre>
<p>os.Open函数返回的err其实是实现了接口error的os.Patherror的指针，是一个error接口类型，所以可以进行断言：</p>
<pre><code class="language-go">import( &quot;fmt&quot; &quot;os&quot; )
func main(){
	file,err:=os.Open(&quot;test.txt&quot;)
    if val,ok:=err.(*os.Patherror){
		fmt.Println(val.Error()) //output no such file or directory
	}
}
</code></pre>
<p>因此，这提供了一种处理错误的思路，我们可以自定义一个结构体，这个结构体的字段是我们在遇到错误时需要的信息字段，例如errmsg、errcode，然后对这个结构体实现接口error，在编写函数返回值时，返回类型指定为error类型，返回该结构体的指针（如果不是指针，变成值传递，临时变量会销毁），然后进行类型断言，确保是某类错误后，再去获取错误信息。返回的error对象应该是最好是最后一个变量（规范化）。</p>
<pre><code class="language-go">type s1 struct {
	radius float32
}
func (s s1) Error() string {
	return &quot;error from s1&quot;
}

func test_error() (int, error) {
	return -1, new(s1)
}

func main(){
	_, myerr := test_error()
	if val, ok := myerr.(*s1); ok {
		fmt.Println(val.Error())
	}
}//output error from s1
</code></pre>
<hr>
<h3 id="go语言异常处理">Go语言异常处理</h3>
<p>在程序编写时，尽量使用错误而不是异常处理，因为异常往往是程序要崩溃了。</p>
<p>常见的异常为访问野指针导致段错误，或者程序指定要绑定某个端口，但反复重试后仍无法绑定，则抛出异常。</p>
<p>go中抛出异常使用的函数为<strong>panic</strong>函数，这个函数的作用很像C++中的throw，<strong>运行时程序崩溃其实也是调用了panic函数</strong>。panic是会不断往外层函数传递的，直到有函数处理了它，或者没有函数处理进而程序退出。</p>
<pre><code class="language-go">func panic(v interface{})
</code></pre>
<p>当调用panic函数后程序终止了，会打印传入给panic的参数，同时还会打印函数调用栈，类同backtrace，返回堆栈信息</p>
<pre><code class="language-go">func main(){
	panic(&quot;exit at start&quot;)
}

//output
panic: exit at start

goroutine 1 [running]:
main.main()
        /root/learn_go/var.go:80 +0x39
exit status 2
</code></pre>
<h4 id="延迟函数延迟语句-关键字defer">延迟函数/延迟语句 关键字：defer</h4>
<p><strong>在异常情况下（调用panic函数或程序崩溃时）</strong>：使用defer关键字，后面跟的语句、函数会在panic函数调用后/程序退出前执行，类似于apue中的atexit函数，执行的顺序和defer语句的执行顺序相反（栈结构）</p>
<p>defer语句虽然是在其所在函数返回后再进行执行，但如果defer语句中的表达式求值在程序运行到该语句时就执行了求值，例如defer函数的参数在此时已经确定了，即使后面更改了传入的参数的值，也没有影响：</p>
<pre><code class="language-go">func df(a, b int) int {
	return a + b
}
func main(){
	a := 10
	b := 20
	defer fmt.Println(df(a, b))
	a += b
	fmt.Println(a + b)
}//output
50 //main中最后一行打印的结果
30 //defer函数的执行结果
</code></pre>
<pre><code class="language-go">func test_defer(){
	defer fmt.Println(&quot;defer in test_defer&quot;)
	panic(&quot;panic in test_defer&quot;)
}
func main(){
	defer fmt.Println(&quot;defer in main&quot;)
}
//output
defer in test_defer
defer in main
panic: panic in test_defer

goroutine 1 [running]:
main.test_defer()
        /root/learn_go/var.go:81 +0x95
main.main()
        /root/learn_go/var.go:86 +0xb1
exit status 2
</code></pre>
<p>可以看到，每个defer都会把语句压入栈中，等到<strong>程序退出前</strong>（正常退出或者panic退出）再从栈顶逐一执行，先压入了main的defer，后压入了test_defer函数中的defer语句。</p>
<p><strong>在执行完所有的defer语句后，再执行panic函数。</strong></p>
<p><strong>正常情况下</strong>：在某个函数中使用了defer语句，则在该函数return前，会执行所有在该函数中注册的每个defer语句，然后再return。只要函数不return或者异常结束，该函数内声明的defer语句都不会执行。</p>
<pre><code class="language-go">func test_defer() string {
	defer fmt.Println(&quot;defer in test_defer&quot;)
    defer fmt.Println(&quot;defer in test_defer 2&quot;)
	return &quot;hello&quot;

}
func main() {
	defer fmt.Println(&quot;defer in main&quot;)
	fmt.Println(test_defer())
}
//output
defer in test_defer 2
defer in test_defer
hello
defer in main

</code></pre>
<p><strong>在正常情况下</strong>，defer语句的执行顺序是：<strong>先return，后再执行defer语句</strong>。</p>
<pre><code class="language-go">func test_defer() int {
	i := 0
	defer func() {
		i++
		fmt.Println(&quot;first state defer&quot;, i)
	}()
	defer func() {
		i++
		fmt.Println(&quot;second state defer&quot;, i)
	}()
	return i
}
func main(){
	fmt.Println(test_defer())
}
//output
second state defer 1
first state defer 2
0

</code></pre>
<h4 id="recover函数">recover函数</h4>
<p>程序在panic之后，调用recover可以恢复程序，不让程序崩溃退出，有点像C++的catch异常的感觉。只要处理了异常，就不会使得程序退出。</p>
<p>A call to <code>recover</code> stops the unwinding and returns the argument passed to <code>panic</code>.</p>
<p><strong>recover函数返回值是传给panic函数的参数</strong>，返回类型就是interface{}，这个类型就是panic函数形参类型。</p>
<p>只能够在延迟函数中调用recover函数来恢复程序，直接调用是不行的：</p>
<pre><code class="language-go">func test_defer(){
	defer func(){
		recover()
		fmt.Println(&quot;recovered&quot;)
	}()
	panic(&quot;panic in test_defer&quot;)
}
func main(){
	test_defer()
	fmt.Println(&quot;in main&quot;)
}
//output
recovered
in main

</code></pre>
<p>在与recover搭配的情况下，<strong>panic其实是提前中断了其所在的函数</strong>（panic代码所在行后所有的语句是不会执行的），其会在所在的函数体内，找defer函数中是否有调用recover，<strong>没有的话就返回上一层函数，继续寻找</strong>，如果都没找到，则程序结束，否则程序恢复正常运行，不会退出：</p>
<pre><code class="language-go">func test(){
	panic(&quot;panic in test&quot;)
}
func main(){
	defer func(){
		recover()
		fmt.Println(&quot;recovered&quot;)
	}()
	fmt.Println(&quot;normal output&quot;)
}
//output 
recovered

</code></pre>
<p>可以看到上述代码中，即使recover从panic中恢复了，但仍然没有输出normal output，这是因为test函数中没有recover，panic传到了外层main函数，main函数提前终止，然后才调用了defer语句，才有了接下来的输出。</p>
<p>除了自己调用panic，运行时也会出现panic，例如未知的情况下访问了野指针，也可以通过recover来恢复，不过这需要在可能出现panic的函数体的第一句就写好延迟函数：</p>
<pre><code class="language-go">func may_panic(){
	defer func(){
		recover()
	}
	/* code */
}

</code></pre>
<p>A call to <code>recover</code> stops the unwinding and returns the argument passed to <code>panic</code>. Because the only code that runs while unwinding is inside deferred functions, <code>recover</code> is only useful inside deferred functions.</p>
<p>下面的例子可用于理解为什么defer函数是在return之后执行的</p>
<pre><code class="language-go">// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}

</code></pre>
<p>上面这个例子可能存在一个re-panic现象，也即如果e.(Error)这个类型判断失败，会再一次引起panic，这就是所谓的在处理异常的过程中又发生了异常，这时候就会再往上找recover函数，同时，<strong>re-panic的每一次panic信息都会打印。</strong></p>
<p>defer函数在return之后调用的原因：上面这个函数在return的地方调用了函数，而这个函数可能出现panic，此时defer函数才可以发挥作用，执行recover；否则这个panic就没办法在Compile函数内部被捕捉。</p>
<p>此外，<strong>defer函数可以修改命名的返回值</strong>，可以看到defer函数内部，在panic后，将regexp赋值为nil。</p>
<p>实践例子：</p>
<pre><code class="language-go">func derfer_test() (s string) {
	defer func() {
		s = &quot;changed in defer&quot;
	}()
	return &quot;Not change&quot;
}
func main(){
	fmt.Println(defer_test())
}
//output
changed in defer

</code></pre>
<p>使用panic和recover的建议，这一套应该在package中处理，不应该暴露给用户，应是package出现了panic后，使用recover返回一个error给用户，避免暴露panic信息给用户。</p>
<p>Useful though this pattern is, it should be used only within a package. <code>Parse</code> turns its internal <code>panic</code> calls into <code>error</code> values; it does not expose <code>panics</code> to its client. That is a good rule to follow.</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-bing-fa/">
                <h3 class="post-title">
                  Go语言并发
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://rexxxzhou.github.io/images/avatar.png?v=1678621911113" class="no-responsive avatar">
    <div class="text-muted">Life is a fucking movie, enjoy.</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/effectivego-bi-ji/">EffectiveGo笔记</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-wang-luo-kai-fa/">Go语言网络开发</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-shu-zu-yu-qie-pian/">Go语言数组与切片</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-lei-xing/">Go语言类型</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-kong-zhi-liu/">Go语言控制流</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-ji-chu-zhi-shi/">Go语言基础知识</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-han-shu/">Go语言函数</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-de-yi-xie-nei-zhi-han-shu/">Go语言的一些内置函数</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-cuo-wu-chu-li/">Go语言错误处理</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-bing-fa/">Go语言并发</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://rexxxzhou.github.io/tag/bzcKfnF8X/" class="badge warning">
          Golang
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/Jnf5LaxTP/" class="badge success">
          apue读书笔记
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/hPjfg7vfX/" class="badge secondary">
          python
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/fOn--vI2w/" class="badge warning">
          日常开发知识沉淀
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/ESBJ9vM7t/" class="badge secondary">
          apisix
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/R9r12TtWy/" class="badge secondary">
          lua
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/MF20Z50u8/" class="badge secondary">
          git
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/e43sinOSt/" class="badge ">
          MySQL
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/m7J2bceGd/" class="badge secondary">
          HTTP
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/m3a3xDoDi/" class="badge secondary">
          ElasticSearch
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://rexxxzhou.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5746490084885111"
     crossorigin="anonymous"></script>




  </body>
</html>
