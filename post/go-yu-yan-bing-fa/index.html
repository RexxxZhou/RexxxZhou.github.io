<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Go语言并发 | Rexxxx&#39;s Blog</title>
<meta name="description" content="Life is a fucking movie, enjoy.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://rexxxzhou.github.io/favicon.ico?v=1678621911113">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://rexxxzhou.github.io/styles/main.css">


<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://rexxxzhou.github.io">Rexxxx&#39;s Blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Go语言并发</h1>
            <p class="article-meta">
              2022-08-28
              
                <a href="https://rexxxzhou.github.io/tag/bzcKfnF8X/" class="badge secondary">
                  Golang
                </a>
              
            </p>
            
            <div class="post-content" v-pre>
              <h3 id="go语言并发">Go语言并发</h3>
<p>在go语言中，程序是以goroutine的形式执行的，每个goroutine就是一个轻量级用户线程，可以使用关键字go来说生成一个新的线程去执行函数，类似于创建thread时指定它要执行的函数：</p>
<pre><code class="language-go">func test_go() {
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	time.Sleep(time.Second)
}
//output
helloworld
</code></pre>
<h4 id="gpm模型">GPM模型</h4>
<p>每个 P 都有一个队列，用来存正在执行的 G。避免 Global Sched Lock。</p>
<p>每个 M 运行都需要一个 MCache 结构。M Pool 中通常有较多 M，但执行的只有几个，为每个池子中的每个 M 分配一个 MCache 则会形成不必要的浪费，通过把 cache 从 M 移到 P，每个运行的 M 都有关联的 P，这样只有运行的 M 才有自己的 MCache。</p>
<p>Goroutine的增长是在堆上分配空间的。</p>
<p>https://zhuanlan.zhihu.com/p/323271088</p>
<p>https://www.zhihu.com/question/20862617</p>
<p>教程：https://www.bilibili.com/video/BV19r4y1w7Nx</p>
<p>G(goroutine),P(processor),M(工作线程)，三者要互相绑定，才能正常运行。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/rexxxzhou/mdpicsrepo/raw/master/pic/20210622/165745367-1.png" alt="image" loading="lazy"></figure>
<h4 id="信道-chan">信道 chan</h4>
<p><strong>信道是一个先进先出的数据结构，可以看作一个线程安全的队列。</strong></p>
<p>go语言中，每个goroutine可以通过channel变量进行通信，来感知别的线程的工作情况。</p>
<p>channel变量在不指定缓冲区大小的情况下是无缓冲的</p>
<p><code>make(chan int , 2) </code>返回的是一个缓冲区大小为2的信道，这个<strong>返回值作用像是一个指向底层数据结构的引用</strong>。所以在函数间进行作为参数进行传递就跟传引用一样，都引用/使用这个底层信道数据对象。</p>
<pre><code class="language-go">c:=make(chan int) //创建一个信道内传递整数的无缓冲信道

//在函数外声明chan变量
var c chan int=make(chan int)
</code></pre>
<p>对于无缓冲的信道，对信道的读和写都是阻塞的。无缓冲的信道不做数据的存储，只体现为数据的流通。</p>
<p>1.对于写而言，如果没有goroutine从信道读取，则写的goroutine会被阻塞挂起</p>
<p>​	写的语法：<code>channel&lt;-5</code></p>
<p>2.对于读而言，如果没有goroutine对信道写入，则读的goroutine会被阻塞挂起</p>
<p>​	读的语法：<code>&lt;-channel</code></p>
<pre><code class="language-go">var channel chan int = make(chan int) //必须要make赋值，否则是个nil的chan，行为会异常

func test_go() {
	channel &lt;- 5
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	&lt;-channel
	time.Sleep(time.Second)
}
//output helloworld
</code></pre>
<p>因此，<strong>对于无缓冲的信道，读写必须是成套的</strong>，在没有成套之前，goroutine会被挂起，所以这里也很容易出现死锁问题。</p>
<p>go语言在运行时能感知到信道的死锁，若出现死锁，运行时报错：</p>
<pre><code>fatal error: all goroutines are asleep - deadlock!
</code></pre>
<p>缓冲信道，在使用make创建信道时，可以指定信道的大小，也即缓冲区的大小。这时的信道有点像容器一样，可以装最多缓冲区大小的元素。</p>
<pre><code class="language-go">c2:=make(chan int,2) //创建一个信道内传递整数的缓冲去大小为2的信道

//在函数外声明chan变量
var c2 chan int=make(chan int,2)
</code></pre>
<p>若信道缓冲区已满，后续对信道的写入将会阻塞，goroutine会被挂起；同理，如果信道缓冲区为空，则读取操作讲阻塞挂起。带缓冲的信道就和TCP连接的独写处理方式相似了。</p>
<p><strong>控制信道的读写权限</strong>：</p>
<pre><code class="language-go">var c1 chan int //可读可写
var c2 &lt;-chan int //只读
var c3 chan&lt;- int //只写
</code></pre>
<h5 id="信道的读取和关闭">信道的读取和关闭</h5>
<p>带缓冲的信道如果某一时刻有很多个值在里面，逐一使用&lt;-channel的方式来读取代码上重复累赘，使用range可以遍历信道的元素（<strong>遍历操作就是读取</strong>），但如果信道是没有关闭的（即还能往信道里写入值），那么range的遍历是不会终止的，它会一直等下一个元素的到来，此时也会产生死锁。</p>
<pre><code class="language-go">var channel chan string = make(chan string, 1)

func test_go() {
	channel &lt;- &quot;hello&quot;
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	for ele := range channel {
		fmt.Println(ele)
	}
	time.Sleep(time.Second)
}
//output
helloworld
hello
fatal error: all goroutines are asleep - deadlock!
</code></pre>
<p>要么就是在for循环内添加if判断，判断信道当前大小<code>len(channel)</code>是否为0，是的话则break，但这种方法一定要保证没有其他的goroutine同时往信道写入，否则用于不会break。</p>
<p>另外一种方式就是关闭信道，<code>close(channel)</code>，关闭信道只是关闭了写入了，仍可正常读取，和TCP的close有点相像。</p>
<pre><code class="language-go">var channel chan string = make(chan string, 1)

func test_go() {
	channel &lt;- &quot;hello&quot;
	close(channel)
	fmt.Println(&quot;helloworld&quot;)
}

func main() {
	go test_go()
	time.Sleep(time.Second)
	for ele := range channel {
		fmt.Println(ele)
	}
}
//output
helloworld
hello
</code></pre>
<p>或者通过<code>val,ok:=&lt;-channel</code>的方式来遍历也可以，<strong>如果信道关闭了则ok为false，停止循环</strong>：</p>
<pre><code class="language-go">	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}

</code></pre>
<p><strong>向一个关闭了信道继续写数据会引起程序panic</strong></p>
<h5 id="信道作为函数参数传递">信道作为函数参数传递</h5>
<p>不论是值传递还是传指针，<strong>效果跟传引用一样</strong>，修改了传入的信道：</p>
<pre><code class="language-go">//example 1
func test_trans(c *chan string) {
	*c &lt;- &quot;world&quot;
	close(*c)
}
func main() {
	test_trans(&amp;channel)
	time.Sleep(time.Second)
	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}
	fmt.Println(len(channel))
} //output world 0

//example 2
func test_trans(c chan string) {
	c &lt;- &quot;world&quot;
	close(c)
}
func main() {
	test_trans(channel)
	time.Sleep(time.Second)
	for {
		if val, ok := &lt;-channel; ok {
			fmt.Println(val)
		} else {
			break
		}
	}
	fmt.Println(len(channel))
} //output world 0

</code></pre>
<p>channel底层的数据结构，<strong>多个goroutine同时访问一个channel是协程安全的</strong>，因为底层数据结构有一个mutex互斥量，以保证每次从channel的写入和取出操作都是互斥的，原子性的，所以可以放心使用，效率和共享的队列应该差不多，毕竟都是用mutex来控制。</p>
<pre><code class="language-go">type hchan struct {
    // 通道里元素的数量
    qcount   uint
	// 循环队列的长度
    dataqsiz uint
	// 指针，指向存储缓冲通道数据的循环队列
    buf      unsafe.Pointer
	// 通道中元素的大小
    elemsize uint16
	// 通道是否关闭的标志
    closed   uint32
	// 通道中元素的类型
    elemtype *_type
	// 已接收元素在循环队列的索引
    sendx    uint  
	// 已发送元素在循环队列的索引
    recvx    uint
	// 等待接收的协程队列
    recvq    waitq
	// 等待发送的协程队列
    sendq    waitq
	// 互斥锁，保护hchan的并发读写，下文会讲
    lock mutex
}

</code></pre>
<p>————————————————<br>
原文链接：https://blog.csdn.net/jiangjiang04/article/details/105481940/</p>
<h3 id="syncmutex">sync.Mutex</h3>
<p>虽然使用chan变量可以实现不同goroutine之间的通信和同步，但有时候我们并不需要goroutine之间通信，而需要他们在访问同一共享对象时互斥，这时候就可以使用Go标准库提供的sync.Mutex互斥锁，原理上和C++的mutex是一样的，同一时刻只有一个goroutine获得了锁标记。<strong>Mutex在Go标准库sync包中</strong>。</p>
<pre><code class="language-go">import &quot;sync&quot;
type HasLock struct{
	mutex sync.Mutex
}
var global int = 20
func test_mutex(hl *HasLock){
	hl.mutex.Lock()
	fmt.Println(global++)
	hl.mutex.UnLock()
}
func main(){
	local_mutex:=HasLock{}
	for i:=0;i&lt;10;i++{
		go test_mutex(&amp;local_mutex)
	}
	time.Sleep(time.Second*5)
}
//output
21
22
23
24
25
26
27
28
29
30

</code></pre>
<hr>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func() {
            process(req) // Buggy; see explanation below.
            &lt;-sem
        }()
    }
}

</code></pre>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func(req *Request) {
            process(req)
            &lt;-sem
        }(req)
    }
}

</code></pre>
<p>注意上述两块代码，第一块代码中存在bug，原因是每个goroutine都复用了for循环中的局部变量req，共享了req（官网是这样解释的， 但是个人觉得好像没影响，感觉每次循环的req的值都不一样，应该不存在共享变量的问题）；第二块代码则是通过闭包的方式，每个goroutine都有自己req的副本，不存在共享问题，也可像下面这样：</p>
<pre><code class="language-go">func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem &lt;- 1
        go func() {
            process(req)
            &lt;-sem
        }()
    }
}

</code></pre>
<p>注意比较奇怪的语法：在循环体内部用了req:=req，虽然看起来奇怪，但是go语言支持。</p>
<p>You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine.</p>
<hr>
<p>获取电脑的CPU核数：<code>runtime.NumCPU()</code></p>
<p>获取配置文件中的GOMAXPROCS参数：<code>runtime.GOMAXPROCS(0)</code></p>
<p>can</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-reflect-fan-she/">
                <h3 class="post-title">
                  Go语言reflect反射
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://rexxxzhou.github.io/images/avatar.png?v=1678621911113" class="no-responsive avatar">
    <div class="text-muted">Life is a fucking movie, enjoy.</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/effectivego-bi-ji/">EffectiveGo笔记</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-wang-luo-kai-fa/">Go语言网络开发</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-shu-zu-yu-qie-pian/">Go语言数组与切片</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-lei-xing/">Go语言类型</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-kong-zhi-liu/">Go语言控制流</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-ji-chu-zhi-shi/">Go语言基础知识</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-han-shu/">Go语言函数</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-de-yi-xie-nei-zhi-han-shu/">Go语言的一些内置函数</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-cuo-wu-chu-li/">Go语言错误处理</a>
            </li>
          
        
          
            <li>
              <a href="https://rexxxzhou.github.io/post/go-yu-yan-bing-fa/">Go语言并发</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://rexxxzhou.github.io/tag/bzcKfnF8X/" class="badge secondary">
          Golang
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/Jnf5LaxTP/" class="badge success">
          apue读书笔记
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/hPjfg7vfX/" class="badge secondary">
          python
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/fOn--vI2w/" class="badge ">
          日常开发知识沉淀
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/ESBJ9vM7t/" class="badge secondary">
          apisix
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/R9r12TtWy/" class="badge secondary">
          lua
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/MF20Z50u8/" class="badge secondary">
          git
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/e43sinOSt/" class="badge secondary">
          MySQL
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/m7J2bceGd/" class="badge secondary">
          HTTP
        </a>
      
        <a href="https://rexxxzhou.github.io/tag/m3a3xDoDi/" class="badge secondary">
          ElasticSearch
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://rexxxzhou.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5746490084885111"
     crossorigin="anonymous"></script>




  </body>
</html>
